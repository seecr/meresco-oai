Changeset created on Fri Mar  4 11:27:05 CET 2011 by Seek You Too

Description: Extracted PeriodicDownload from OaiHarvester

    Extracted PeriodicDownload from OaiHarvester

Baseline version: meresco-oai/workingsets/3.4-MWE/version_0

diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_0/meresco/oai/__init__.py version_0-RDF-harvester/meresco/oai/__init__.py
--- version_0/meresco/oai/__init__.py	2010-12-07 09:03:41.000000000 +0100
+++ version_0-RDF-harvester/meresco/oai/__init__.py	2010-12-07 12:04:58.000000000 +0100
@@ -38,6 +38,7 @@
 from oaijazz import OaiJazz
 from oaiaddrecord import OaiAddRecord, OaiAddRecordWithDefaults
 from oaisuspend import OaiSuspend
-from oaiharvester import OaiHarvester
+from periodicdownload import PeriodicDownload
+from oaidownloadprocessor import OaiDownloadProcessor
 from updateadapter import UpdateAdapterFromOaiHarvester
 from oaibranding import OaiBranding
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_0/meresco/oai/oaidownloadprocessor.py version_0-RDF-harvester/meresco/oai/oaidownloadprocessor.py
--- version_0/meresco/oai/oaidownloadprocessor.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-RDF-harvester/meresco/oai/oaidownloadprocessor.py	2010-12-07 12:37:38.000000000 +0100
@@ -0,0 +1,108 @@
+## begin license ##
+#
+#    Meresco Oai are components to build Oai repositories, based on Meresco
+#    Core and Meresco Components.
+#    Copyright (C) 2010 Stichting Kennisnet Ict op school.
+#       http://www.kennisnetictopschool.nl
+#
+#    This file is part of Meresco Oai.
+#
+#    Meresco Oai is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Meresco Oai is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Meresco Oai; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+from socket import socket, error as SocketError, SHUT_WR, SHUT_RD, SOL_SOCKET, SO_ERROR
+from errno import EINPROGRESS, ECONNREFUSED
+from lxml.etree import parse, ElementTree
+from StringIO import StringIO
+from traceback import format_exc
+from os import makedirs, close, remove
+from os.path import join, isfile, isdir
+from urllib import urlencode
+
+from meresco.core import Observable
+from meresco.components.http.utils import CRLF
+from weightless import compose
+
+from sys import stderr, stdout
+from time import time
+from tempfile import mkstemp
+
+namespaces = {'oai': "http://www.openarchives.org/OAI/2.0/"}
+
+class OaiDownloadProcessor(Observable):
+    def __init__(self, path, metadataPrefix, workingDirectory, xWait=True, err=None):
+        Observable.__init__(self)
+        self._metadataPrefix = metadataPrefix
+        self._resumptionToken = None
+        self._xWait = xWait
+        self._path = path
+        self._err = err or stderr
+
+        isdir(workingDirectory) or makedirs(workingDirectory)
+        self._stateFilePath = join(workingDirectory, "harvester.state")
+        self._readState()
+
+    def buildRequest(self):
+        arguments = [('verb', 'ListRecords')]
+        if self._resumptionToken:
+            arguments.append(('resumptionToken', self._resumptionToken))
+        else:
+            arguments.append(('metadataPrefix', self._metadataPrefix))
+        if self._xWait:
+            arguments.append(('x-wait', 'True'))
+        statusline = "GET %s?%s HTTP/1.0\r\n\r\n"
+        return statusline % (self._path, urlencode(arguments))
+
+    def handle(self, lxmlNode):
+        try:
+            errors = xpath(lxmlNode, "/oai:OAI-PMH/oai:error")
+            if len(errors) > 0:
+                for error in errors:
+                    self._logError("%s: %s" % (error.get("code"), error.text))
+                self._resumptionToken = None
+            else:
+                records = xpath(lxmlNode, '/oai:OAI-PMH/oai:ListRecords/oai:record')
+                for record in records:
+                    self.do.add(lxmlNode=ElementTree(record))
+                    yield
+                self._resumptionToken = head(xpath(lxmlNode, "/oai:OAI-PMH/oai:ListRecords/oai:resumptionToken/text()"))
+        finally:
+            self._writeState()
+
+    def _writeState(self):
+        open(self._stateFilePath, 'w').write("%s%s" % (RESUMPTIONTOKEN_STATE, self._resumptionToken))
+
+    def _readState(self):
+        self._resumptionToken = ''
+        if isfile(self._stateFilePath):
+            state = open(self._stateFilePath).read()
+            if RESUMPTIONTOKEN_STATE in state:
+                self._resumptionToken = state.split(RESUMPTIONTOKEN_STATE)[-1].strip()
+
+    def _logError(self, message):
+        self._err.write(message)
+        if not message.endswith('\n'):
+            self._err.write('\n')
+        self._err.flush()
+
+def head(l):
+    return l[0] if l else ""
+
+def xpath(node, path):
+    return node.xpath(path, namespaces=namespaces)
+
+RESUMPTIONTOKEN_STATE = "Resumptiontoken: "
+
Only in version_0/meresco/oai: oaiharvester.py
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_0/meresco/oai/periodicdownload.py version_0-RDF-harvester/meresco/oai/periodicdownload.py
--- version_0/meresco/oai/periodicdownload.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-RDF-harvester/meresco/oai/periodicdownload.py	2010-12-10 09:28:38.000000000 +0100
@@ -0,0 +1,151 @@
+## begin license ##
+#
+#    Meresco Oai are components to build Oai repositories, based on Meresco
+#    Core and Meresco Components.
+#    Copyright (C) 2010 Stichting Kennisnet Ict op school.
+#       http://www.kennisnetictopschool.nl
+#
+#    This file is part of Meresco Oai.
+#
+#    Meresco Oai is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Meresco Oai is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Meresco Oai; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+from socket import socket, error as SocketError, SHUT_WR, SHUT_RD, SOL_SOCKET, SO_ERROR
+from errno import EINPROGRESS, ECONNREFUSED
+from lxml.etree import parse, ElementTree
+from StringIO import StringIO
+from traceback import format_exc
+from os import makedirs, close, remove
+from os.path import join, isfile, isdir
+from urllib import urlencode
+
+from meresco.core import Observable
+from meresco.components.http.utils import CRLF
+from weightless import compose
+
+from sys import stderr, stdout
+from time import time
+from tempfile import mkstemp
+
+class AlwaysReadable(object):
+    def __init__(self):
+        self._fd, self._name = mkstemp('periodicdownload')
+
+    def fileno(self):
+        return self._fd
+
+    def cleanUp(self):
+        close(self._fd)
+        remove(self._name)
+
+
+class PeriodicDownload(Observable):
+    def __init__(self, reactor, host, port, period=1, verbose=False, prio=None, err=None):
+        super(PeriodicDownload, self).__init__()
+        self._reactor = reactor
+        self._host = host
+        self._port = port 
+        self._period = period
+        self._prio = prio
+        self._err = err or stderr
+        if not verbose:
+            self._log = lambda x: None
+
+    def observer_init(self):
+        self._loop = compose(self.loop())
+        self._reactor.addTimer(1, self._loop.next)
+
+    def loop(self):
+        while True:
+            sok = yield self._tryConnect()
+            sok.send(self.any.buildRequest())
+            sok.shutdown(SHUT_WR)
+            self._reactor.addReader(sok, self._loop.next, prio=self._prio)
+            responses = []
+            try:
+                while True:
+                    yield
+                    response = sok.recv(4096)
+                    if response == '':
+                         break
+                    responses.append(response)
+            except SocketError, (errno, msg):
+                yield self._retryAfterError("Receive error: %s: %s" % (errno, msg))
+                continue
+            self._reactor.removeReader(sok)
+            sok.close()
+            try:
+                response = ''.join(responses)
+                headers, body = response.split(2 * CRLF, 1)
+                statusLine = headers.split(CRLF)[0]
+                if not statusLine.strip().lower().endswith('200 ok'):
+                    yield self._retryAfterError('Unexpected response: ' + statusLine)
+                    continue
+                lxmlNode = parse(StringIO(body))
+                alwaysReadable = AlwaysReadable()
+                self._reactor.addReader(alwaysReadable, self._loop.next, prio=self._prio)
+                try:
+                    result = self.any.handle(lxmlNode=lxmlNode)
+                    yield result 
+                finally:
+                    self._reactor.removeReader(alwaysReadable)
+                    alwaysReadable.cleanUp()
+            except Exception:
+                self._logError(format_exc())
+            self._reactor.addTimer(self._period, self._loop.next)
+            yield
+    
+    def _tryConnect(self):
+        sok = socket()
+        sok.setblocking(0)
+        while True:
+            try:
+                sok.connect((self._host, self._port))
+            except SocketError, (errno, msg):
+                if errno != EINPROGRESS:
+                    yield self._retryAfterError("%s: %s" % (errno, msg))
+                    continue
+            self._reactor.addWriter(sok, self._loop.next)
+            yield
+            self._reactor.removeWriter(sok)
+
+            err = sok.getsockopt(SOL_SOCKET, SO_ERROR)
+            if err == ECONNREFUSED:
+                yield self._retryAfterError("Connection refused.")
+                continue
+            if err != 0:   # any other error
+                raise IOError(err)
+            break
+        raise StopIteration(sok)
+
+    def _retryAfterError(self, message):
+        self._logError(message)
+        self._reactor.addTimer(self._period, self._loop.next)
+        yield
+        
+    def _logError(self, message):
+        self._err.write("%s:%d: " % (self._host, self._port))
+        self._err.write(message)
+        if not message.endswith('\n'):
+            self._err.write('\n')
+        self._err.flush()
+
+    def _log(self, message):
+        stdout.write(message)
+        if not message.endswith('\n'):
+            stdout.write('\n')
+        stdout.flush()
+
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_0/test/_alltests.py version_0-RDF-harvester/test/_alltests.py
--- version_0/test/_alltests.py	2010-12-07 09:03:41.000000000 +0100
+++ version_0-RDF-harvester/test/_alltests.py	2010-12-07 09:55:41.000000000 +0100
@@ -48,8 +48,9 @@
 from fields2oairecordtest import Fields2OaiRecordTest
 from oaiaddrecordtest import OaiAddRecordTest
 from oaibrandingtest import OaiBrandingTest
+from oaidownloadprocessortest import OaiDownloadProcessorTest
 from oaigetrecordtest import OaiGetRecordTest
-from oaiharvestertest import OaiHarvesterTest
+from periodicdownloadtest import PeriodicDownloadTest 
 from oaiidentifytest import OaiIdentifyTest
 from oaijazzimplementationstest import OaiJazzImplementationsTest
 from oaijazztest import OaiJazzTest
@@ -65,6 +66,7 @@
 from oaitooltest import OaiToolTest
 from resumptiontokentest import ResumptionTokenTest
 from updateadaptertest import UpdateAdapterTest
+from streaminglxmltest import StreamingLxmlTest
 
 if __name__ == '__main__':
     unittest.main()
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_0/test/oaidownloadprocessortest.py version_0-RDF-harvester/test/oaidownloadprocessortest.py
--- version_0/test/oaidownloadprocessortest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-RDF-harvester/test/oaidownloadprocessortest.py	2010-12-07 12:03:11.000000000 +0100
@@ -0,0 +1,148 @@
+## begin license ##
+#
+#    Meresco Oai are components to build Oai repositories, based on Meresco
+#    Core and Meresco Components.
+#    Copyright (C) 2010 Stichting Kennisnet Ict op school.
+#       http://www.kennisnetictopschool.nl
+#
+#    This file is part of Meresco Oai.
+#
+#    Meresco Oai is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Meresco Oai is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Meresco Oai; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+from __future__ import with_statement
+from contextlib import contextmanager
+from random import randint
+from threading import Event, Thread
+from time import sleep
+from socket import socket, error as SocketError
+from lxml.etree import tostring, parse
+from StringIO import StringIO
+from os.path import join
+from urllib import urlencode
+
+from cq2utils import CQ2TestCase, CallTrace
+from meresco.core import Observable, be
+from meresco.components.http.utils import CRLF
+from meresco.oai import OaiDownloadProcessor
+
+
+class OaiDownloadProcessorTest(CQ2TestCase):
+    def testRequest(self):
+        oaiDownloadProcessor = OaiDownloadProcessor(path="/oai", metadataPrefix="oai_dc", workingDirectory=self.tempdir, xWait=True)
+        self.assertEquals("""GET /oai?verb=ListRecords&metadataPrefix=oai_dc&x-wait=True HTTP/1.0\r\n\r\n""", oaiDownloadProcessor.buildRequest())
+
+    def testHandle(self): 
+        observer = CallTrace()
+        oaiDownloadProcessor = OaiDownloadProcessor(path="/oai", metadataPrefix="oai_dc", workingDirectory=self.tempdir, xWait=True)
+        oaiDownloadProcessor.addObserver(observer)
+        list(oaiDownloadProcessor.handle(parse(StringIO(LISTRECORDS_RESPONSE % ''))))
+        self.assertEquals(['add'], [m.name for m in observer.calledMethods])
+        self.assertEquals(0, len(observer.calledMethods[0].args))
+        self.assertEqualsWS(ONE_RECORD, tostring(observer.calledMethods[0].kwargs['lxmlNode']))
+
+    def testHandleWithTwoRecords(self): 
+        observer = CallTrace()
+        oaiDownloadProcessor = OaiDownloadProcessor(path="/oai", metadataPrefix="oai_dc", workingDirectory=self.tempdir, xWait=True)
+        oaiDownloadProcessor.addObserver(observer)
+        list(oaiDownloadProcessor.handle(parse(StringIO(LISTRECORDS_RESPONSE % '<record>another record</record>'))))
+        self.assertEquals(['add', 'add'], [m.name for m in observer.calledMethods])
+        self.assertEquals(0, len(observer.calledMethods[0].args))
+        self.assertEqualsWS(ONE_RECORD, tostring(observer.calledMethods[0].kwargs['lxmlNode']))
+        self.assertEqualsWS('<record xmlns="http://www.openarchives.org/OAI/2.0/">another record</record>', tostring(observer.calledMethods[1].kwargs['lxmlNode']))
+
+    def testListRecordsRequestError(self):
+        resumptionToken = "u|c1286437597991025|mprefix|s|f"
+        open(join(self.tempdir, 'harvester.state'), 'w').write("Resumptiontoken: %s\n" % resumptionToken)
+        observer = CallTrace()
+        oaiDownloadProcessor = OaiDownloadProcessor(path="/oai", metadataPrefix="oai_dc", workingDirectory=self.tempdir, xWait=True, err=StringIO())
+        oaiDownloadProcessor.addObserver(observer)
+        self.assertEquals('GET /oai?%s HTTP/1.0\r\n\r\n' % urlencode([('verb', 'ListRecords'), ('resumptionToken', resumptionToken), ('x-wait', 'True')]), oaiDownloadProcessor.buildRequest())
+        list(oaiDownloadProcessor.handle(parse(StringIO(ERROR_RESPONSE))))
+        self.assertEquals(0, len(observer.calledMethods))
+        self.assertEquals("someError: Some error occurred.\n", oaiDownloadProcessor._err.getvalue())
+        self.assertEquals('GET /oai?%s HTTP/1.0\r\n\r\n' % urlencode([('verb', 'ListRecords'), ('metadataPrefix', 'oai_dc'), ('x-wait', 'True')]), oaiDownloadProcessor.buildRequest())
+
+    def testUseResumptionToken(self):
+        observer = CallTrace()
+        oaiDownloadProcessor = OaiDownloadProcessor(path="/oai", metadataPrefix="oai_dc", workingDirectory=self.tempdir, xWait=True, err=StringIO())
+        oaiDownloadProcessor.addObserver(observer)
+        list(oaiDownloadProcessor.handle(parse(StringIO(LISTRECORDS_RESPONSE % RESUMPTION_TOKEN))))
+        self.assertEquals('x?y&z', oaiDownloadProcessor._resumptionToken)
+        self.assertEquals('Resumptiontoken: x?y&z', open(oaiDownloadProcessor._stateFilePath).read())
+        self.assertEquals('GET /oai?verb=ListRecords&resumptionToken=x%3Fy%26z&x-wait=True HTTP/1.0\r\n\r\n', oaiDownloadProcessor.buildRequest())
+        oaiDownloadProcessor = OaiDownloadProcessor(path="/oai", metadataPrefix="oai_dc", workingDirectory=self.tempdir, xWait=True, err=StringIO())
+        self.assertEquals('x?y&z', oaiDownloadProcessor._resumptionToken)
+
+    def testReadResumptionTokenFromStateWithNewline(self):
+        resumptionToken = "u|c1286437597991025|mprefix|s|f"
+        open(join(self.tempdir, 'harvester.state'), 'w').write("Resumptiontoken: %s\n" % resumptionToken)
+        oaiDownloadProcessor = OaiDownloadProcessor(path="/oai", metadataPrefix="oai_dc", workingDirectory=self.tempdir, xWait=True, err=StringIO())
+        self.assertEquals(resumptionToken, oaiDownloadProcessor._resumptionToken)
+
+    def testReadResumptionTokenWhenNoState(self):
+        oaiDownloadProcessor = OaiDownloadProcessor(path="/oai", metadataPrefix="oai_dc", workingDirectory=self.tempdir, xWait=True, err=StringIO())
+        self.assertEquals('', oaiDownloadProcessor._resumptionToken)
+
+    def testReadInvalidState(self):
+        open(join(self.tempdir, 'harvester.state'), 'w').write("invalid")
+        oaiDownloadProcessor = OaiDownloadProcessor(path="/oai", metadataPrefix="oai_dc", workingDirectory=self.tempdir, xWait=True, err=StringIO())
+        self.assertEquals('', oaiDownloadProcessor._resumptionToken)
+
+    def testKeepResumptionTokenOnFailingAddCall(self):
+        resumptionToken = "u|c1286437597991025|mprefix|s|f"
+        open(join(self.tempdir, 'harvester.state'), 'w').write("Resumptiontoken: %s\n" % resumptionToken)
+        observer = CallTrace()
+        observer.exceptions={'add': Exception("Could be anything")}
+        oaiDownloadProcessor = OaiDownloadProcessor(path="/oai", metadataPrefix="oai_dc", workingDirectory=self.tempdir, xWait=True, err=StringIO())
+        oaiDownloadProcessor.addObserver(observer)
+        self.assertEquals('GET /oai?%s HTTP/1.0\r\n\r\n' % urlencode([('verb', 'ListRecords'), ('resumptionToken', resumptionToken), ('x-wait', 'True')]), oaiDownloadProcessor.buildRequest())
+        self.assertRaises(Exception, lambda: list(oaiDownloadProcessor.handle(parse(StringIO(LISTRECORDS_RESPONSE)))))
+        self.assertEquals(['add'], [m.name for m in observer.calledMethods])
+        self.assertEquals("", oaiDownloadProcessor._err.getvalue())
+        self.assertEquals('GET /oai?%s HTTP/1.0\r\n\r\n' % urlencode([('verb', 'ListRecords'), ('resumptionToken', resumptionToken), ('x-wait', 'True')]), oaiDownloadProcessor.buildRequest())
+
+
+ONE_RECORD = '<record xmlns="http://www.openarchives.org/OAI/2.0/">ignored</record>'
+
+LISTRECORDS_RESPONSE = """<?xml version="1.0" encoding="UTF-8" ?>
+<OAI-PMH xmlns="http://www.openarchives.org/OAI/2.0/">
+  <responseDate>2002-06-01T19:20:30Z</responseDate>
+  <request verb="ListRecords" from="1998-01-15" 
+           metadataPrefix="dc">http://an.oa.org/OAI-script</request>
+  <ListRecords>
+    <record>ignored</record>
+    %s
+  </ListRecords>
+</OAI-PMH>
+"""
+
+ERROR_RESPONSE = """<?xml version="1.0" encoding="UTF-8" ?>
+<OAI-PMH xmlns="http://www.openarchives.org/OAI/2.0/" 
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://www.openarchives.org/OAI/2.0/
+         http://www.openarchives.org/OAI/2.0/OAI-PMH.xsd">
+  <responseDate>2002-06-01T19:20:30Z</responseDate>
+  <request verb="ListRecords" from="1998-01-15" 
+           metadataPrefix="dc">http://an.oa.org/OAI-script</request>
+  <error code="someError">Some error occurred.</error>
+</OAI-PMH>
+"""
+ 
+RESUMPTION_TOKEN = """<resumptionToken expirationDate="2002-06-01T23:20:00Z" 
+      completeListSize="6" 
+      cursor="0">x?y&amp;z</resumptionToken>"""
+
Only in version_0/test: oaiharvestertest.py
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_0/test/oaisuspendtest.py version_0-RDF-harvester/test/oaisuspendtest.py
--- version_0/test/oaisuspendtest.py	2010-12-07 09:03:41.000000000 +0100
+++ version_0-RDF-harvester/test/oaisuspendtest.py	2010-12-07 10:43:33.000000000 +0100
@@ -31,7 +31,7 @@
 from meresco.core import be, Observable
 from meresco.components.http import ObservableHttpServer
 from meresco.components import StorageComponent
-from meresco.oai import OaiPmh, OaiJazz, OaiSuspend, OaiHarvester
+from meresco.oai import OaiPmh, OaiJazz, OaiSuspend, PeriodicDownload, OaiDownloadProcessor
 
 from cq2utils import CQ2TestCase, CallTrace
 from weightless import Suspend, Reactor
@@ -169,8 +169,10 @@
         reactor = Reactor()
         server = be(
             (Observable(),
-                (OaiHarvester(reactor, 'localhost', portNumber, '/', 'prefix', self.tempdir),
-                    (observer,),
+                (PeriodicDownload(reactor, 'localhost', portNumber),
+                    (OaiDownloadProcessor('/', 'prefix', self.tempdir),
+                        (observer,),
+                    )
                 )
             )
         )
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_0/test/periodicdownloadtest.py version_0-RDF-harvester/test/periodicdownloadtest.py
--- version_0/test/periodicdownloadtest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-RDF-harvester/test/periodicdownloadtest.py	2010-12-10 09:55:28.000000000 +0100
@@ -0,0 +1,248 @@
+## begin license ##
+#
+#    Meresco Oai are components to build Oai repositories, based on Meresco
+#    Core and Meresco Components.
+#    Copyright (C) 2010 Stichting Kennisnet Ict op school.
+#       http://www.kennisnetictopschool.nl
+#
+#    This file is part of Meresco Oai.
+#
+#    Meresco Oai is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Meresco Oai is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Meresco Oai; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+from __future__ import with_statement
+from contextlib import contextmanager
+from random import randint
+from threading import Event, Thread
+from time import sleep
+from socket import socket, error as SocketError
+from lxml.etree import tostring
+from StringIO import StringIO
+from os.path import join
+
+from cq2utils import CQ2TestCase, CallTrace
+from meresco.core import Observable, be
+from meresco.components.http.utils import CRLF
+from meresco.oai import PeriodicDownload
+
+DROP_CONNECTION = object()
+
+@contextmanager
+def server(responses, bufsize=4096):
+    port = randint(10000,60000)
+    start = Event()
+    messages = []
+    def serverThread():
+        s = socket()
+        s.bind(('127.0.0.1', port))
+        s.listen(0)
+        start.set()
+        for response in responses:
+            connection, address = s.accept()
+            msg = connection.recv(bufsize)
+            messages.append(msg)
+            if not response is DROP_CONNECTION:
+                connection.send(response)
+                connection.close()
+    thread = Thread(None, serverThread)
+    thread.start()
+    start.wait()
+    yield port, messages
+    thread.join()
+
+
+class PeriodicDownloadTest(CQ2TestCase):
+    def testOne(self):
+        reactor = CallTrace("reactor")
+        with server([RESPONSE_ONE_RECORD]) as (port, msgs):
+            harvester, observer, reactor = self.getHarvester("localhost", port)
+            self.assertEquals('addTimer', reactor.calledMethods[0].name)
+            self.assertEquals(1, reactor.calledMethods[0].args[0])
+            callback = reactor.calledMethods[0].args[1]
+            callback() # connect
+            self.assertEquals('addWriter', reactor.calledMethods[1].name)
+            callback = reactor.calledMethods[1].args[1]
+            callback() # HTTP GET
+            sleep(0.01)
+            self.assertEquals("GET", msgs[0][:3])
+            self.assertEquals('removeWriter', reactor.calledMethods[2].name)
+            self.assertEquals('addReader', reactor.calledMethods[3].name)
+            self.assertEquals(0, reactor.calledMethods[3].kwargs['prio'])
+            callback = reactor.calledMethods[3].args[1]
+            callback() # sok.recv
+            callback() # sok.recv
+            callback() # yield after self.do.add(...
+            self.assertEquals("", harvester._err.getvalue())
+            self.assertEquals('buildRequest', observer.calledMethods[0].name)
+            self.assertEquals('handle', observer.calledMethods[1].name)
+            self.assertEquals(0, len(observer.calledMethods[1].args))
+            self.assertEquals(['lxmlNode'], observer.calledMethods[1].kwargs.keys())
+            self.assertEqualsWS(ONE_RECORD, tostring(observer.calledMethods[1].kwargs['lxmlNode']))
+
+    def testNoConnectionPossible(self):
+        harvester, observer, reactor = self.getHarvester("some.nl", 'no-port')
+        callback = reactor.calledMethods[0].args[1]
+        try:
+            callback() # connect
+            self.fail()
+        except TypeError, e:
+            self.assertEquals("an integer is required", str(e))
+
+    def testErrorResponse(self):
+        reactor = CallTrace("reactor")
+        with server(['HTTP/1.0 400 Error\r\n\r\nIllegal Request']) as (port, msgs):
+            harvester, observer, reactor = self.getHarvester("localhost", port)
+            callback = reactor.calledMethods[0].args[1]
+            callback() # connect
+            callback = reactor.calledMethods[1].args[1]
+            callback() # HTTP GET
+            sleep(0.01)
+            callback = reactor.calledMethods[3].args[1]
+            callback() # sok.recv
+
+            callback() # yield After Error 
+
+            self.assertEquals("localhost:%d: Unexpected response: HTTP/1.0 400 Error\n" % port, harvester._err.getvalue())
+            self.assertEquals(['buildRequest'], [m.name for m in observer.calledMethods])
+
+    def testInvalidPortConnectionRefused(self):
+        harvester, observer, reactor = self.getHarvester("localhost", 88)
+        callback = reactor.calledMethods[0].args[1]
+        callback() # connect
+        self.assertEquals("addWriter", reactor.calledMethods[1].name)
+        callback() # connect
+        self.assertEquals("removeWriter", reactor.calledMethods[2].name)
+        self.assertEquals("addTimer", reactor.calledMethods[3].name)
+        self.assertEquals("localhost:88: Connection refused.\n", harvester._err.getvalue())
+
+    def testInvalidHost(self):
+        strangeHost = "UEYR^$*FD(#>NDJ.khfd9.(*njnd.nl"
+        harvester, observer, reactor = self.getHarvester(strangeHost, 88)
+        callback = reactor.calledMethods[0].args[1]
+        callback() # connect
+        self.assertEquals('addTimer', reactor.calledMethods[-1].name)
+        nameOrServiceNotKnown = strangeHost + ":88: -2: Name or service not known\n" ==  harvester._err.getvalue()
+        noAddressAssociatedWithHost = strangeHost + ":88: -5: No address associated with hostname\n" == harvester._err.getvalue()
+        self.assertTrue(nameOrServiceNotKnown or noAddressAssociatedWithHost, harvester._err.getvalue())
+
+    def testInvalidHostConnectionRefused(self):
+        harvester, observer, reactor = self.getHarvester("127.0.0.255", 9876)
+        callback = reactor.calledMethods[0].args[1]
+        callback()
+        self.assertEquals("addWriter", reactor.calledMethods[1].name)
+        callback()
+        self.assertEquals("127.0.0.255:9876: Connection refused.\n", harvester._err.getvalue())
+        self.assertEquals("removeWriter", reactor.calledMethods[2].name)
+        self.assertEquals("addTimer", reactor.calledMethods[3].name)
+
+    def testSuccess(self):
+        with server([RESPONSE_TWO_RECORDS]) as (port, msgs):
+            harvester, observer, reactor = self.getHarvester("localhost", port)
+            self.assertEquals(1, harvester._period)
+            callback = self.doConnect()
+            callback() # HTTP GET
+            sleep(0.01)
+            callback = reactor.calledMethods[3].args[1]
+            callback() # sok.recv
+            callback() # recv = ''
+            callback() # yield after self.do.add(...
+            self.assertEquals("", harvester._err.getvalue())
+            self.assertEquals('buildRequest', observer.calledMethods[0].name)
+            self.assertEquals('handle', observer.calledMethods[1].name)
+            self.assertEqualsWS(TWO_RECORDS, tostring(observer.calledMethods[1].kwargs['lxmlNode']))
+            self.assertEquals('removeReader', reactor.calledMethods[-2].name)
+            self.assertEquals('addTimer', reactor.calledMethods[-1].name)
+
+    def testSuccessHttp1dot1Server(self):
+        with server([STATUSLINE_ALTERNATIVE + ONE_RECORD]) as (port, msgs):
+            harvester, observer, reactor = self.getHarvester("localhost", port)
+            callback = self.doConnect()
+            callback() # HTTP GET
+            sleep(0.01)
+            callback = reactor.calledMethods[3].args[1]
+            callback() # sok.recv
+            callback() # recv = ''
+            callback() # yield after self.do.add(...
+            self.assertEquals("", harvester._err.getvalue())
+            self.assertEquals('buildRequest', observer.calledMethods[0].name)
+            self.assertEqualsWS(ONE_RECORD, tostring(observer.calledMethods[1].kwargs['lxmlNode']))
+
+    def testPeriod(self):
+        with server([RESPONSE_TWO_RECORDS, 'HTTP/1.0 400 Error\r\n\r\nIllegal Request']) as (port, msgs):
+            harvester, observer, reactor = self.getHarvester("localhost", port, period=2)
+            callback = self.doConnect()
+            callback() # HTTP GET
+            sleep(0.01)
+            callback = reactor.calledMethods[3].args[1]
+            callback() # sok.recv
+            callback() # recv = ''
+            callback() # yield after self.do.add(...
+            self.assertEquals('addTimer', reactor.calledMethods[-1].name)
+            self.assertEquals(2, reactor.calledMethods[-1].args[0])
+            
+            callback = self.doConnect()
+            callback() # HTTP GET
+            sleep(0.01)
+            callback() # sok.recv
+            callback() # recv = ''
+            self.assertEquals('addTimer', reactor.calledMethods[-1].name)
+            self.assertEquals(2, reactor.calledMethods[-1].args[0])
+
+    def testRecoveringAfterDroppedConnection(self):
+        with server([DROP_CONNECTION, RESPONSE_ONE_RECORD]) as (port, msgs):
+            harvester, observer, reactor = self.getHarvester("localhost", port)
+            callback = self.doConnect()
+            callback() # HTTP GET
+            sleep(0.01)
+            callback = reactor.calledMethods[3].args[1]
+            callback() # sok.recv = ''
+            self.assertEquals("localhost:%s: Receive error: 11: Resource temporarily unavailable\n" % port, harvester._err.getvalue()) 
+            callback()
+            callback() # HTTP GET
+            sleep(0.01)
+            self.assertEquals("GET /path?argument=value HTTP/1.0\r\n\r\n", msgs[0])
+            callback() # sok.recv
+            callback() # soc.recv == ''
+            callback() # removeReader() after self.do.add(...
+            self.assertEquals(['buildRequest', 'buildRequest', 'handle'], [m.name for m in observer.calledMethods])
+
+    def getHarvester(self, host, port, period=1):
+        self._reactor = CallTrace("reactor")
+        self._harvester = PeriodicDownload(self._reactor, host, port, period=period, prio=0, err=StringIO())
+        self._observer = CallTrace("observer")
+        self._observer.returnValues["buildRequest"] = "GET /path?argument=value HTTP/1.0\r\n\r\n"
+        self._harvester.addObserver(self._observer)
+        self._harvester.observer_init()
+        self.assertEquals(1, self._reactor.calledMethods[0].args[0])
+        return self._harvester, self._observer, self._reactor
+
+    def doConnect(self):
+        callback = self._reactor.calledMethods[0].args[1]
+        callback() # connect
+        callback = self._reactor.calledMethods[1].args[1]
+        return callback
+
+HTTP_SEPARATOR = 2 * CRLF
+STATUSLINE = """HTTP/1.0 200 OK """ + HTTP_SEPARATOR
+STATUSLINE_ALTERNATIVE = """HTTP/1.1 200 ok """ + HTTP_SEPARATOR
+
+EMBEDDED_RECORD = '<record>ignored</record>'
+BODY = """<aap:noot xmlns:aap="mies">%s</aap:noot>"""
+ONE_RECORD = BODY % (EMBEDDED_RECORD) 
+TWO_RECORDS = BODY % (EMBEDDED_RECORD * 2) 
+RESPONSE_ONE_RECORD = STATUSLINE + ONE_RECORD 
+RESPONSE_TWO_RECORDS = STATUSLINE + TWO_RECORDS 
+
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_0/test/streaminglxmltest.py version_0-RDF-harvester/test/streaminglxmltest.py
--- version_0/test/streaminglxmltest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_0-RDF-harvester/test/streaminglxmltest.py	2010-12-07 09:03:41.000000000 +0100
@@ -0,0 +1,56 @@
+from unittest import TestCase
+from lxml.etree import XMLParser, TreeBuilder, tostring
+
+class Target(object):
+
+    def __init__(self, tagname):
+        self._tagname = tagname
+        self._builder = TreeBuilder()
+        self._rootbuilder = self._builder
+        self._depth = 0
+
+    def start(self, tagname, attrs, nsmap=None):
+        if tagname == self._tagname:
+            if self._depth == 0:
+                self._builder = TreeBuilder()
+            self._depth += 1
+        self._builder.start(tagname, attrs, nsmap)
+    
+    def data(self, *args, **kwargs):
+        self._builder.data(*args, **kwargs)
+
+    def end(self, tagname):
+        self._builder.end(tagname)
+        if tagname == self._tagname:
+            self._depth -= 1
+            if self._depth == 0:
+                self.root = self._builder.close()
+                self._builder = self._rootbuilder
+
+class StreamingLxmlTest(TestCase):
+    def testTwoTags(self):
+        target = Target('aap')
+        p = XMLParser(target = target)
+        p.feed("<aap>")
+        p.feed("noot")
+        p.feed("</aap>")
+        self.assertEquals("<aap>noot</aap>", tostring(target.root))
+
+    def testFilterTag(self):
+        target = Target('mies')
+        p = XMLParser(target = target)
+        p.feed("<aap><mies>")
+        p.feed("noot")
+        p.feed("</mies>")
+        p.feed("</aap>")
+        self.assertEquals("<mies>noot</mies>", tostring(target.root))
+
+
+    def testFilterTag(self):
+        target = Target('mies')
+        p = XMLParser(target = target)
+        p.feed("<mies><mies>")
+        p.feed("noot")
+        p.feed("</mies>")
+        p.feed("</mies>")
+        self.assertEquals("<mies><mies>noot</mies></mies>", tostring(target.root))
