Changeset created on Thu Oct 11 07:51:46 UTC 2012 by Seecr (Seek You Too B.V.)

Description: OaiJazz recovers to a consistent state after crash

    OaiJazz data structure could become inconsistent after a crash or forced 
    termination. Now OaiJazz is guaranteed to recover on a fresh instantiation
    when a 'change' file exists. Also: the number of Berkeley Dict syncs to disk
    was optimized.

Baseline version: 4.0.10.1

From 0971f2f1bcefa3822ecf4d1d61cce7f43fff4211 Mon Sep 17 00:00:00 2001
From: Jurjan-Paul Medema <jurjanpaul@cq2.nl>
Date: Fri, 5 Oct 2012 09:28:39 +0200
Subject: [PATCH 01/11] JPM: got tests to work after some internal refactorings

---
 meresco/oai/oaijazz.py |  161 ++++++++++++++++++++++++++++--------------------
 test/oaijazztest.py    |   16 +++---
 2 files changed, 103 insertions(+), 74 deletions(-)

diff --git a/meresco/oai/oaijazz.py b/meresco/oai/oaijazz.py
index 7a91967..9a638ac 100644
--- a/meresco/oai/oaijazz.py
+++ b/meresco/oai/oaijazz.py
@@ -52,29 +52,34 @@ DATESTAMP_FACTOR, DATESTAMP_FACTOR_FLOAT = 1000000, 1000000.0
 
 class OaiJazz(object):
 
-    version = '2'
+    version = '3'
 
     def __init__(self, aDirectory, alwaysDeleteInPrefixes=None, preciseDatestamp=False, persistentDelete=True, name=None):
-        self._directory = aDirectory
-        isdir(aDirectory) or makedirs(aDirectory)
+        self._directory = _ensureDir(aDirectory)
         self._versionFormatCheck()
-        isdir(join(aDirectory, 'stamp2identifier')) or makedirs(join(aDirectory,'stamp2identifier'))
-        isdir(join(aDirectory, 'identifier2setSpecs')) or makedirs(join(aDirectory,'identifier2setSpecs'))
-        isdir(join(aDirectory, 'sets')) or makedirs(join(aDirectory,'sets'))
-        isdir(join(aDirectory, 'prefixes')) or makedirs(join(aDirectory,'prefixes'))
-        isdir(join(aDirectory, 'prefixesInfo')) or makedirs(join(aDirectory,'prefixesInfo'))
-        self._prefixes = {}
-        self._sets = {}
-        self._stamp2identifier = DoubleUniqueBerkeleyDict(join(self._directory, 'stamp2identifier'))
-        self._tombStones = PersistentSortedIntegerList(join(self._directory, 'tombStones.list'), use64bits=True, mergeTrigger=MERGE_TRIGGER)
-        self._identifier2setSpecs = BerkeleyDict(join(self._directory, 'identifier2setSpecs'))
-        self._read()
-        self._suspended = []
+
         self._deletePrefixes = alwaysDeleteInPrefixes or []
         self._preciseDatestamp = preciseDatestamp
         self._persistentDelete = persistentDelete
-
         self._name = name
+        self._suspended = []
+
+        self._stamp2identifier = DoubleUniqueBerkeleyDict(
+            _ensureDir(join(aDirectory, 'stamp2identifier'))
+        )
+        self._tombStones = PersistentSortedIntegerList(
+            join(self._directory, 'tombStones.list'), 
+            use64bits=True, 
+            mergeTrigger=MERGE_TRIGGER)
+        self._identifier2setSpecs = BerkeleyDict(
+            _ensureDir(join(self._directory, 'identifier2setSpecs')))
+
+        self._sets = {}
+        _ensureDir(join(aDirectory, 'sets'))
+        self._prefixes = {}
+        _ensureDir(join(aDirectory, 'prefixes'))
+        _ensureDir(join(aDirectory, 'prefixesInfo'))
+        self._read()
 
     def observable_name(self):
         return self._name
@@ -88,12 +93,17 @@ class OaiJazz(object):
         assert [prefix for prefix, schema, namespace in metadataFormats], 'No metadataFormat specified for record with identifier "%s"' % identifier
         for setSpec, setName in sets:
             assert SETSPEC_SEPARATOR not in setSpec, 'SetSpec "%s" contains illegal characters' % setSpec
+
+        #(oldStamp, oldPrefixes, oldSets) = self._lookupExisting(identifier)
+        #newStamp = self._newStamp()
+
         oldPrefixes, oldSets = self._purge(identifier)
-        stamp = self._stamp()
+        stamp = self._newStamp()
         prefixes = set(prefix for prefix, schema, namespace in metadataFormats)
         prefixes.update(oldPrefixes)
         setSpecs = _flattenSetHierarchy((setSpec for setSpec, setName in sets))
         setSpecs.update(oldSets)
+
         self._add(stamp, identifier, setSpecs, prefixes)
         self._storeMetadataFormats(metadataFormats)
         self._resume()
@@ -106,11 +116,16 @@ class OaiJazz(object):
         oldPrefixes, oldSets = self._purge(identifier)
         if not oldPrefixes and not self._deletePrefixes:
             return
-        stamp = self._stamp()
+        stamp = self._newStamp()
         self._add(stamp, identifier, oldSets, set(oldPrefixes + self._deletePrefixes))
         self._tombStones.append(stamp)
         self._resume()
 
+    def purge(self, identifier):
+        if self._persistentDelete:
+            raise KeyError("Purging of records is not allowed with persistent deletes.")
+        self._purge(safeString(identifier))
+
     def oaiSelect(self, sets=None, prefix='oai_dc', continueAfter='0', oaiFrom=None, oaiUntil=None, setsMask=None):
         setsMask = setsMask or []
         sets = sets or []
@@ -130,11 +145,6 @@ class OaiJazz(object):
         idAndStamps = ((self._getIdentifier(stampId), stampId) for stampId in stampIds)
         return (RecordId(identifier, stampId) for identifier, stampId in idAndStamps if not identifier is None)
 
-    def _sliceStampIds(self, stampIds, start, stop):
-        if stop:
-            return stampIds[bisect_left(stampIds, start):bisect_left(stampIds, stop)]
-        return stampIds[bisect_left(stampIds, start):]
-                
     def getDatestamp(self, identifier):
         stamp = self.getUnique(identifier)
         if stamp is None:
@@ -190,8 +200,59 @@ class OaiJazz(object):
         yield suspend
         suspend.getResult()
 
+
     # private methods
 
+    def _read(self):
+        for prefix in (unescapeFilename(name[:-len('.list')]) for name in listdir(join(self._directory, 'prefixes')) if name.endswith('.list')):
+            self._getPrefixList(prefix)
+        for setSpec in (unescapeFilename(name[:-len('.list')]) for name in listdir(join(self._directory, 'sets')) if name.endswith('.list')):
+            self._getSetList(setSpec)
+
+    def _getSetList(self, setSpec):
+        if setSpec not in self._sets:
+            filename = join(self._directory, 'sets', '%s.list' % escapeFilename(setSpec))
+            self._sets[setSpec] = PersistentSortedIntegerList(filename, use64bits=True, mergeTrigger=MERGE_TRIGGER)
+        return self._sets[setSpec]
+
+    def _getPrefixList(self, prefix):
+        if prefix not in self._prefixes:
+            filename = join(self._directory, 'prefixes', '%s.list' % escapeFilename(prefix))
+            self._prefixes[prefix] = PersistentSortedIntegerList(filename, use64bits=True, mergeTrigger=MERGE_TRIGGER)
+        return self._prefixes[prefix]
+
+    def _purge(self, identifier):
+        stamp = self.getUnique(identifier)
+        stamp in self._tombStones and self._tombStones.remove(stamp)
+        oldPrefixes = []
+        oldSets = []
+        if stamp != None:
+            del self._stamp2identifier[str(stamp)]
+            for prefix, prefixStamps in self._prefixes.items():
+                if stamp in prefixStamps:
+                    oldPrefixes.append(prefix)
+                    prefixStamps.remove(stamp)
+            if identifier in self._identifier2setSpecs:
+                oldSets = self._identifier2setSpecs[identifier].split(SETSPEC_SEPARATOR)
+                for setSpec in oldSets:
+                    self._sets[setSpec].remove(stamp)
+                del self._identifier2setSpecs[identifier]
+        return oldPrefixes, oldSets
+
+    def _lookupExisting(self, identifier):
+        stamp = self.getUnique(identifier)
+        oldPrefixes = []
+        oldSets = []
+        if not stamp is None:
+            for prefix, prefixStamps in self._prefixes.items():
+                if stamp in prefixStamps:  # Relatively expensive...
+                    oldPrefixes.append(prefix)
+            oldSets = [
+                setSpec 
+                for setSpec in self._identifier2setSpecs.get(identifier, '').split(SETSPEC_SEPARATOR) 
+                if setSpec]
+        return stamp, oldPrefixes, oldSets
+
     def _add(self, stamp, identifier, setSpecs, prefixes):
         try:
             for setSpec in setSpecs:
@@ -217,25 +278,17 @@ class OaiJazz(object):
             except ValueError:
                 pass #ignored because stamp could not have been added.
 
-
     def _getAllMetadataFormats(self):
         for prefix in self._prefixes.keys():
             schema = open(join(self._directory, 'prefixesInfo', '%s.schema' % escapeFilename(prefix))).read()
             namespace = open(join(self._directory, 'prefixesInfo', '%s.namespace' % escapeFilename(prefix))).read()
             yield (prefix, schema, namespace)
 
-    def _getSetList(self, setSpec):
-        if setSpec not in self._sets:
-            filename = join(self._directory, 'sets', '%s.list' % escapeFilename(setSpec))
-            self._sets[setSpec] = PersistentSortedIntegerList(filename, use64bits=True, mergeTrigger=MERGE_TRIGGER)
-        return self._sets[setSpec]
-
-    def _getPrefixList(self, prefix):
-        if prefix not in self._prefixes:
-            filename = join(self._directory, 'prefixes', '%s.list' % escapeFilename(prefix))
-            self._prefixes[prefix] = PersistentSortedIntegerList(filename, use64bits=True, mergeTrigger=MERGE_TRIGGER)
-        return self._prefixes[prefix]
-
+    def _sliceStampIds(self, stampIds, start, stop):
+        if stop:
+            return stampIds[bisect_left(stampIds, start):bisect_left(stampIds, stop)]
+        return stampIds[bisect_left(stampIds, start):]
+                
     def _fromTime(self, oaiFrom):
         if not oaiFrom:
             return 0
@@ -264,41 +317,12 @@ class OaiJazz(object):
             result = int(result)
         return result
 
-    def purge(self, identifier):
-        if self._persistentDelete:
-            raise KeyError("Purging of records is not allowed with persistent deletes.")
-        self._purge(safeString(identifier))
-
-    def _purge(self, identifier):
-        stamp = self.getUnique(identifier)
-        stamp in self._tombStones and self._tombStones.remove(stamp)
-        oldPrefixes = []
-        oldSets = []
-        if stamp != None:
-            del self._stamp2identifier[str(stamp)]
-            for prefix, prefixStamps in self._prefixes.items():
-                if stamp in prefixStamps:
-                    oldPrefixes.append(prefix)
-                    prefixStamps.remove(stamp)
-            if identifier in self._identifier2setSpecs:
-                oldSets = self._identifier2setSpecs[identifier].split(SETSPEC_SEPARATOR)
-                for setSpec in oldSets:
-                    self._sets[setSpec].remove(stamp)
-                del self._identifier2setSpecs[identifier]
-        return oldPrefixes, oldSets
-
-    def _read(self):
-        for prefix in (unescapeFilename(name[:-len('.list')]) for name in listdir(join(self._directory, 'prefixes')) if name.endswith('.list')):
-            self._getPrefixList(prefix)
-        for setSpec in (unescapeFilename(name[:-len('.list')]) for name in listdir(join(self._directory, 'sets')) if name.endswith('.list')):
-            self._getSetList(setSpec)
-
     def _storeMetadataFormats(self, metadataFormats):
         for prefix, schema, namespace in metadataFormats:
             _write(join(self._directory, 'prefixesInfo', '%s.schema' % escapeFilename(prefix)), schema)
             _write(join(self._directory, 'prefixesInfo', '%s.namespace' % escapeFilename(prefix)), namespace)
 
-    def _stamp(self):
+    def _newStamp(self):
         """time in microseconds"""
         return int(time()*DATESTAMP_FACTOR_FLOAT)
 
@@ -356,3 +380,8 @@ def stamp2zulutime(stamp):
 def _stamp2zulutime(stamp, preciseDatestamp=False):
     microseconds = ".%s" % (stamp % DATESTAMP_FACTOR) if preciseDatestamp else ""
     return "%s%sZ" % (strftime('%Y-%m-%dT%H:%M:%S', gmtime(stamp/DATESTAMP_FACTOR_FLOAT)), microseconds)
+
+def _ensureDir(directory):
+    isdir(directory) or makedirs(directory) 
+    return directory
+
diff --git a/test/oaijazztest.py b/test/oaijazztest.py
index 6df2d84..03ebd9c 100644
--- a/test/oaijazztest.py
+++ b/test/oaijazztest.py
@@ -60,7 +60,7 @@ class OaiJazzTest(SeecrTestCase):
             result = self.stampNumber
             self.stampNumber += 1
             return result
-        self.jazz._stamp = stamp
+        self.jazz._newStamp = stamp
         self.oaiAddRecord = OaiAddRecord()
         self.oaiAddRecord.addObserver(self.jazz)
 
@@ -76,9 +76,9 @@ class OaiJazzTest(SeecrTestCase):
 
     def testOriginalStamp(self):
         jazz = OaiJazz(self.tempdir)
-        stamp0 = jazz._stamp()
+        stamp0 = jazz._newStamp()
         sleep(0.0001)
-        stamp1 = jazz._stamp()
+        stamp1 = jazz._newStamp()
         self.assertTrue(stamp0 < stamp1, "Expected %s < %s" % (stamp0, stamp1))
 
     def testResultsStored(self):
@@ -114,7 +114,7 @@ class OaiJazzTest(SeecrTestCase):
         jazz = OaiJazz(self.tempdir)
         t5 = time()
         print t1 - t0, t2 - t1, t3 -t2, t3 -t1, t4 - t3, t5 - t4
-        # a set form 10 million records costs 3.9 seconds (Without any efficiency things applied
+        # a set of 10 million records costs 3.9 seconds (Without any efficiency things applied
         # it costs 0.3 seconds with 1 million records
         # retimed it at 2009-01-13:
         #  1 * 10**6 oaiSelect took 3.7 seconds
@@ -140,7 +140,7 @@ class OaiJazzTest(SeecrTestCase):
 
     def testGetPreciseDatestamp(self):
         jazz = OaiJazz(self.tempdir, preciseDatestamp=True)
-        jazz._stamp = self.jazz._stamp
+        jazz._newStamp = self.jazz._newStamp
         jazz.addOaiRecord('123', metadataFormats=[('oai_dc', 'schema', 'namespace')])
         self.assertEquals('2008-07-06T05:04:03.123456Z', jazz.getDatestamp('123'))
 
@@ -302,9 +302,9 @@ class OaiJazzTest(SeecrTestCase):
         self.assertEquals(2, self.jazz.getNrOfRecords('aPrefix'))
 
     def testGetLastStampId(self):
-        stampFunction = self.jazz._stamp
+        stampFunction = self.jazz._newStamp
         self.jazz = OaiJazz(self.tempdir, persistentDelete=False)
-        self.jazz._stamp = stampFunction
+        self.jazz._newStamp = stampFunction
         self.assertEquals(None, self.jazz.getLastStampId('aPrefix'))
         newStamp = self.stampNumber
         self.jazz.addOaiRecord('id1', metadataFormats=[('aPrefix', 'schema', 'namespace')])
@@ -542,7 +542,7 @@ class OaiJazzTest(SeecrTestCase):
         
     def testListRecordsWithFromAndUntil(self):
         def setTime(year, month, day):
-            self.jazz._stamp = lambda: int(timegm((year, month, day, 0, 1, 0, 0, 0 ,0))*1000000.0)
+            self.jazz._newStamp = lambda: int(timegm((year, month, day, 0, 1, 0, 0, 0 ,0))*1000000.0)
         setTime(2007, 9, 21)
         self.jazz.addOaiRecord('4', metadataFormats=[('prefix','schema', 'namespace')])
         setTime(2007, 9, 22)
-- 
1.7.2.5


From 3a4ffe0aac6264564170b2efb4350b587f0abba1 Mon Sep 17 00:00:00 2001
From: Jurjan-Paul Medema <jurjanpaul@cq2.nl>
Date: Fri, 5 Oct 2012 16:51:29 +0200
Subject: [PATCH 02/11] JPM: refactored OaiJazz to be self recoverable (untested so far); TODO: optimize!

---
 meresco/oai/oaijazz.py     |  193 ++++++++++++++++++++++++++------------------
 test/oaiintegrationtest.py |   45 +++++-----
 test/oaijazztest.py        |    9 +-
 3 files changed, 142 insertions(+), 105 deletions(-)

diff --git a/meresco/oai/oaijazz.py b/meresco/oai/oaijazz.py
index 9a638ac..b82eb1f 100644
--- a/meresco/oai/oaijazz.py
+++ b/meresco/oai/oaijazz.py
@@ -31,19 +31,20 @@
 # 
 ## end license ##
 
-from __future__ import with_statement
+from sys import maxint
 from os.path import isdir, join, isfile
-from os import makedirs, listdir, rename
-from escaping import escapeFilename, unescapeFilename
+from os import makedirs, listdir, rename, remove
+from bisect import bisect_left
 from time import time, strftime, gmtime, strptime
 from calendar import timegm
+from json import dumps, load as jsonLoad
+
+from escaping import escapeFilename, unescapeFilename
 from meresco.components.sorteditertools import OrIterator, AndIterator
 from meresco.components import PersistentSortedIntegerList, DoubleUniqueBerkeleyDict, BerkeleyDict
 from meresco.core import asyncreturn
-from sys import maxint
 from weightless.io import Suspend
 
-from bisect import bisect_left
 
 MERGE_TRIGGER = 1000
 SETSPEC_SEPARATOR = ','
@@ -57,7 +58,6 @@ class OaiJazz(object):
     def __init__(self, aDirectory, alwaysDeleteInPrefixes=None, preciseDatestamp=False, persistentDelete=True, name=None):
         self._directory = _ensureDir(aDirectory)
         self._versionFormatCheck()
-
         self._deletePrefixes = alwaysDeleteInPrefixes or []
         self._preciseDatestamp = preciseDatestamp
         self._persistentDelete = persistentDelete
@@ -65,26 +65,28 @@ class OaiJazz(object):
         self._suspended = []
 
         self._stamp2identifier = DoubleUniqueBerkeleyDict(
-            _ensureDir(join(aDirectory, 'stamp2identifier'))
-        )
+            _ensureDir(join(aDirectory, 'stamp2identifier')))
         self._tombStones = PersistentSortedIntegerList(
             join(self._directory, 'tombStones.list'), 
             use64bits=True, 
             mergeTrigger=MERGE_TRIGGER)
         self._identifier2setSpecs = BerkeleyDict(
             _ensureDir(join(self._directory, 'identifier2setSpecs')))
-
-        self._sets = {}
-        _ensureDir(join(aDirectory, 'sets'))
+        self._prefixesInfoDir = _ensureDir(join(aDirectory, 'prefixesInfo'))
+        self._prefixesDir = _ensureDir(join(aDirectory, 'prefixes'))
         self._prefixes = {}
-        _ensureDir(join(aDirectory, 'prefixes'))
-        _ensureDir(join(aDirectory, 'prefixesInfo'))
+        self._setsDir = _ensureDir(join(aDirectory, 'sets'))
+        self._sets = {}
+        self._actionFile = join(self._directory, 'action.json')
+        self._newestStamp = 0
         self._read()
+        self._maybeRecover()
 
     def observable_name(self):
         return self._name
 
     def addOaiRecord(self, identifier, sets=None, metadataFormats=None):
+        self._maybeRecover()
         if not identifier:
             raise ValueError("Empty identifier not allowed.")
         identifier = safeString(identifier)
@@ -93,38 +95,47 @@ class OaiJazz(object):
         assert [prefix for prefix, schema, namespace in metadataFormats], 'No metadataFormat specified for record with identifier "%s"' % identifier
         for setSpec, setName in sets:
             assert SETSPEC_SEPARATOR not in setSpec, 'SetSpec "%s" contains illegal characters' % setSpec
+        self._storeMetadataFormats(metadataFormats)
 
-        #(oldStamp, oldPrefixes, oldSets) = self._lookupExisting(identifier)
-        #newStamp = self._newStamp()
-
-        oldPrefixes, oldSets = self._purge(identifier)
-        stamp = self._newStamp()
+        oldStamp, oldPrefixes, oldSets = self._lookupExisting(identifier)
         prefixes = set(prefix for prefix, schema, namespace in metadataFormats)
         prefixes.update(oldPrefixes)
         setSpecs = _flattenSetHierarchy((setSpec for setSpec, setName in sets))
         setSpecs.update(oldSets)
 
-        self._add(stamp, identifier, setSpecs, prefixes)
-        self._storeMetadataFormats(metadataFormats)
+        self._saveForRecoveryAndApply(identifier=identifier, oldStamp=oldStamp, newStamp=self._newStamp(), delete=False, prefixes=list(prefixes), setSpecs=list(setSpecs)) 
         self._resume()
 
     @asyncreturn
     def delete(self, identifier):
+        self._maybeRecover()
         if not identifier:
             raise ValueError("Empty identifier not allowed.")
         identifier = safeString(identifier)
-        oldPrefixes, oldSets = self._purge(identifier)
-        if not oldPrefixes and not self._deletePrefixes:
+        oldStamp, oldPrefixes, oldSets = self._lookupExisting(identifier)
+        if not oldStamp and not self._deletePrefixes:
             return
-        stamp = self._newStamp()
-        self._add(stamp, identifier, oldSets, set(oldPrefixes + self._deletePrefixes))
-        self._tombStones.append(stamp)
+        self._saveForRecoveryAndApply(
+            identifier=identifier, 
+            oldStamp=oldStamp, 
+            newStamp=self._newStamp(), 
+            delete=True, 
+            prefixes=list(set(oldPrefixes + self._deletePrefixes)), 
+            setSpecs=list(oldSets))
         self._resume()
 
     def purge(self, identifier):
+        self._maybeRecover()
         if self._persistentDelete:
             raise KeyError("Purging of records is not allowed with persistent deletes.")
-        self._purge(safeString(identifier))
+        identifier = safeString(identifier)
+        oldStamp, oldPrefixes, oldSets = self._lookupExisting(identifier)
+        if not oldStamp:
+            return
+        self._saveForRecoveryAndApply(
+            identifier=identifier, 
+            oldStamp=oldStamp, 
+            newStamp=None) 
 
     def oaiSelect(self, sets=None, prefix='oai_dc', continueAfter='0', oaiFrom=None, oaiUntil=None, setsMask=None):
         setsMask = setsMask or []
@@ -200,44 +211,31 @@ class OaiJazz(object):
         yield suspend
         suspend.getResult()
 
-
     # private methods
 
     def _read(self):
-        for prefix in (unescapeFilename(name[:-len('.list')]) for name in listdir(join(self._directory, 'prefixes')) if name.endswith('.list')):
+        for prefix in (unescapeFilename(name[:-len('.list')]) for name in listdir(self._prefixesDir) if name.endswith('.list')):
             self._getPrefixList(prefix)
-        for setSpec in (unescapeFilename(name[:-len('.list')]) for name in listdir(join(self._directory, 'sets')) if name.endswith('.list')):
+        for setSpec in (unescapeFilename(name[:-len('.list')]) for name in listdir(self._setsDir) if name.endswith('.list')):
             self._getSetList(setSpec)
 
     def _getSetList(self, setSpec):
         if setSpec not in self._sets:
-            filename = join(self._directory, 'sets', '%s.list' % escapeFilename(setSpec))
-            self._sets[setSpec] = PersistentSortedIntegerList(filename, use64bits=True, mergeTrigger=MERGE_TRIGGER)
+            filename = join(self._setsDir, '%s.list' % escapeFilename(setSpec))
+            l = self._sets[setSpec] = PersistentSortedIntegerList(filename, use64bits=True, mergeTrigger=MERGE_TRIGGER)
+            self._newestStampFromList(l)
         return self._sets[setSpec]
 
     def _getPrefixList(self, prefix):
         if prefix not in self._prefixes:
-            filename = join(self._directory, 'prefixes', '%s.list' % escapeFilename(prefix))
-            self._prefixes[prefix] = PersistentSortedIntegerList(filename, use64bits=True, mergeTrigger=MERGE_TRIGGER)
+            filename = join(self._prefixesDir, '%s.list' % escapeFilename(prefix))
+            l = self._prefixes[prefix] = PersistentSortedIntegerList(filename, use64bits=True, mergeTrigger=MERGE_TRIGGER)
+            self._newestStampFromList(l)
         return self._prefixes[prefix]
 
-    def _purge(self, identifier):
-        stamp = self.getUnique(identifier)
-        stamp in self._tombStones and self._tombStones.remove(stamp)
-        oldPrefixes = []
-        oldSets = []
-        if stamp != None:
-            del self._stamp2identifier[str(stamp)]
-            for prefix, prefixStamps in self._prefixes.items():
-                if stamp in prefixStamps:
-                    oldPrefixes.append(prefix)
-                    prefixStamps.remove(stamp)
-            if identifier in self._identifier2setSpecs:
-                oldSets = self._identifier2setSpecs[identifier].split(SETSPEC_SEPARATOR)
-                for setSpec in oldSets:
-                    self._sets[setSpec].remove(stamp)
-                del self._identifier2setSpecs[identifier]
-        return oldPrefixes, oldSets
+    def _newestStampFromList(self, l):
+        if len(l):
+            self._newestStamp = max(self._newestStamp, l[-1])
 
     def _lookupExisting(self, identifier):
         stamp = self.getUnique(identifier)
@@ -253,35 +251,61 @@ class OaiJazz(object):
                 if setSpec]
         return stamp, oldPrefixes, oldSets
 
-    def _add(self, stamp, identifier, setSpecs, prefixes):
+    def _saveForRecoveryAndApply(self, **kwargs):
+        _write(self._actionFile, dumps(kwargs))
+        self._applyAction(**kwargs)
+        remove(self._actionFile)
+
+    def _maybeRecover(self):
+        if isfile(self._actionFile + '.tmp'):
+            remove(self._actionFile + '.tmp')
+            return
+        if isfile(self._actionFile):
+            action = jsonLoad(self._actionFile)
+            self._applyAction(**action)
+            remove(self._actionFile)
+
+    def _applyAction(self, identifier, oldStamp=None, newStamp=None, delete=False, prefixes=None, setSpecs=None):
+        if not oldStamp is None:
+            self._purge(identifier, oldStamp)
+        if not newStamp is None:
+            self._add(identifier, newStamp, prefixes, setSpecs)
+            if delete:
+                self._tombStones.append(newStamp)
+
+    def _purge(self, identifier, oldStamp):        
+        _removeIfInList(oldStamp, self._tombStones)
         try:
-            for setSpec in setSpecs:
-                self._getSetList(setSpec).append(stamp)
-            for prefix in prefixes:
-                self._getPrefixList(prefix).append(stamp)
-            self._stamp2identifier[str(stamp)]=identifier
-            if setSpecs:
-                self._identifier2setSpecs[identifier] = SETSPEC_SEPARATOR.join(setSpecs) 
-        except ValueError, e:
-            self._rollback(stamp, identifier, setSpecs, prefixes)
-            raise ValueError('Timestamp error, original message: "%s"' % str(e))
-
-    def _rollback(self, stamp, identifier, setSpecs, prefixes):
-        for setSpec in setSpecs:
-            try:
-                self._getSetList(setSpec).remove(stamp)
-            except ValueError:
-                pass #ignored because stamp could not have been added.
+            del self._stamp2identifier[str(oldStamp)]
+        except KeyError:
+            # already done apparently
+            pass
+        for prefix, prefixStamps in self._prefixes.items():
+            _removeIfInList(oldStamp, prefixStamps)
+        try:
+            oldSets = self._identifier2setSpecs[identifier].split(SETSPEC_SEPARATOR)
+        except KeyError:
+            # already done apparently
+            pass
+        else:
+            for setSpec in oldSets:
+                _removeIfInList(oldStamp, self._sets[setSpec])
+            del self._identifier2setSpecs[identifier]
+
+    def _add(self, identifier, newStamp, prefixes, setSpecs):
+        self._newestStamp = newStamp
         for prefix in prefixes:
-            try:
-                self._getPrefixList(prefix).remove(stamp)
-            except ValueError:
-                pass #ignored because stamp could not have been added.
-
+            _appendIfNotYet(newStamp, self._getPrefixList(prefix))
+        for setSpec in setSpecs:
+            _appendIfNotYet(newStamp, self._getSetList(setSpec))
+        if setSpecs:
+            self._identifier2setSpecs[identifier] = SETSPEC_SEPARATOR.join(setSpecs) 
+        self._stamp2identifier[str(newStamp)] = identifier
+        
     def _getAllMetadataFormats(self):
         for prefix in self._prefixes.keys():
-            schema = open(join(self._directory, 'prefixesInfo', '%s.schema' % escapeFilename(prefix))).read()
-            namespace = open(join(self._directory, 'prefixesInfo', '%s.namespace' % escapeFilename(prefix))).read()
+            schema = open(join(self._prefixesInfoDir, '%s.schema' % escapeFilename(prefix))).read()
+            namespace = open(join(self._prefixesInfoDir, '%s.namespace' % escapeFilename(prefix))).read()
             yield (prefix, schema, namespace)
 
     def _sliceStampIds(self, stampIds, start, stop):
@@ -319,12 +343,15 @@ class OaiJazz(object):
 
     def _storeMetadataFormats(self, metadataFormats):
         for prefix, schema, namespace in metadataFormats:
-            _write(join(self._directory, 'prefixesInfo', '%s.schema' % escapeFilename(prefix)), schema)
-            _write(join(self._directory, 'prefixesInfo', '%s.namespace' % escapeFilename(prefix)), namespace)
+            _write(join(self._prefixesInfoDir, '%s.schema' % escapeFilename(prefix)), schema)
+            _write(join(self._prefixesInfoDir, '%s.namespace' % escapeFilename(prefix)), namespace)
 
     def _newStamp(self):
         """time in microseconds"""
-        return int(time()*DATESTAMP_FACTOR_FLOAT)
+        newStamp = int(time() * DATESTAMP_FACTOR_FLOAT)
+        if newStamp <= self._newestStamp:
+            raise ValueError("Timestamp error: new stamp '%s' lower than existing ('%s')" % (newStamp, self._newestStamp))
+        return newStamp
 
     def _versionFormatCheck(self):
         if isdir(join(self._directory, 'sets')):
@@ -385,3 +412,13 @@ def _ensureDir(directory):
     isdir(directory) or makedirs(directory) 
     return directory
 
+def _removeIfInList(item, l):
+    try:
+        l.remove(item)
+    except ValueError:
+        pass
+
+def _appendIfNotYet(item, l):
+    if len(l) == 0 or l[-1] != item:
+        l.append(item)
+
diff --git a/test/oaiintegrationtest.py b/test/oaiintegrationtest.py
index 85a4c2f..089588e 100644
--- a/test/oaiintegrationtest.py
+++ b/test/oaiintegrationtest.py
@@ -55,31 +55,32 @@ class OaiIntegrationTest(SeecrTestCase):
         harvestThread = Thread(None, lambda: self.startOaiHarvester(portNumber, observer))
         oaiPmhThread.start()
         harvestThread.start()
-
-        requests = 3
-        sleep(1.0 + 1.0 * requests)
-       
-        self.assertEquals(['add'] * requests, [m.name for m in observer.calledMethods])
-        ids = [xpath(m.kwargs['lxmlNode'], '//oai:header/oai:identifier/text()') for m in observer.calledMethods]
-        self.assertEquals([['id0'],['id1'],['id2']], ids)
-
-        self.assertEquals(1, len(oaiJazz._suspended))
-
-        requests += 1
-        list(compose(storageComponent.add("id3", "prefix", "<a>a3</a>")))
-        oaiJazz.addOaiRecord(identifier="id3", sets=[], metadataFormats=[("prefix", "", "")])
-        sleep(0.1)
-
-        self.assertEquals(0, len(oaiJazz._suspended))
-        self.assertEquals(['add'] * requests, [m.name for m in observer.calledMethods])
-        kwarg = tostring(observer.calledMethods[-1].kwargs['lxmlNode'])
-        self.assertTrue("id3" in kwarg, kwarg)
-        sleep(1.0)
-        self.assertEquals(1, len(oaiJazz._suspended))
-
-        self.run = False
-        oaiPmhThread.join()
-        harvestThread.join()
+        
+        try:
+            requests = 3
+            sleep(1.0 + 1.0 * requests)
+           
+            self.assertEquals(['add'] * requests, [m.name for m in observer.calledMethods])
+            ids = [xpath(m.kwargs['lxmlNode'], '//oai:header/oai:identifier/text()') for m in observer.calledMethods]
+            self.assertEquals([['id0'],['id1'],['id2']], ids)
+
+            self.assertEquals(1, len(oaiJazz._suspended))
+
+            requests += 1
+            list(compose(storageComponent.add("id3", "prefix", "<a>a3</a>")))
+            oaiJazz.addOaiRecord(identifier="id3", sets=[], metadataFormats=[("prefix", "", "")])
+            sleep(1)
+
+            self.assertEquals(0, len(oaiJazz._suspended))
+            self.assertEquals(['add'] * requests, [m.name for m in observer.calledMethods])
+            kwarg = tostring(observer.calledMethods[-1].kwargs['lxmlNode'])
+            self.assertTrue("id3" in kwarg, kwarg)
+            sleep(1.0)
+            self.assertEquals(1, len(oaiJazz._suspended))
+        finally: 
+            self.run = False
+            oaiPmhThread.join()
+            harvestThread.join()
 
     def testNearRealtimeOaiSavesState(self):
         observer = CallTrace("observer", ignoredAttributes=["observer_init"], methods={'add': lambda **kwargs: (x for x in [])})
diff --git a/test/oaijazztest.py b/test/oaijazztest.py
index 03ebd9c..b66bdbb 100644
--- a/test/oaijazztest.py
+++ b/test/oaijazztest.py
@@ -55,6 +55,7 @@ class OaiJazzTest(SeecrTestCase):
     def setUp(self):
         SeecrTestCase.setUp(self)
         self.jazz = OaiJazz(self.tempdir)
+        self._originalNewStamp = self.jazz._newStamp
         self.stampNumber = self.orginalStampNumber = int((timegm((2008, 07, 06, 05, 04, 03, 0, 0, 1))+.123456)*1000000)
         def stamp():
             result = self.stampNumber
@@ -247,21 +248,19 @@ class OaiJazzTest(SeecrTestCase):
         self.assertNotEquals(unique, int(self.jazz.getUnique('23')))
 
     def testTimeUpdateRaisesErrorButLeavesIndexCorrect(self):
+        self.jazz._newStamp = self._originalNewStamp
         self.jazz.addOaiRecord('42', metadataFormats=[('oai_dc','schema', 'namespace')])
-        self.stampNumber -= 12345 # time corrected by -0.012345 seconds
-        nextStampNumber = self.stampNumber
+        self.jazz._newestStamp += 12345  # time corrected by 0.012345 seconds
         try:
             self.jazz.addOaiRecord('43', sets=[('setSpec', 'setName')], metadataFormats=[('other', 'schema', 'namespace'), ('oai_dc','schema', 'namespace')])
             self.fail()
         except ValueError, e:
-            self.assertEquals('Timestamp error, original message: "list.append(%s): expected value to be greater than %s"' % (nextStampNumber, self.orginalStampNumber), str(e))
+            self.assertTrue(str(e).startswith('Timestamp error: '), str(e))
 
         self.assertEquals(0, len(self.jazz._getSetList('setSpec')))
         self.assertEquals(0, len(self.jazz._getPrefixList('other')))
         self.assertEquals(1, len(self.jazz._getPrefixList('oai_dc')))
 
-
-
     def testFlattenSetHierarchy(self):
         self.assertEquals(['set1', 'set1:set2', 'set1:set2:set3'], sorted(_flattenSetHierarchy(['set1:set2:set3'])))
         self.assertEquals(['set1', 'set1:set2', 'set1:set2:set3', 'set1:set2:set4'], sorted(_flattenSetHierarchy(['set1:set2:set3', 'set1:set2:set4'])))
-- 
1.7.2.5


From b9eeb4f103a11ab781eb1281ede22c0c9960d43f Mon Sep 17 00:00:00 2001
From: Jurjan-Paul Medema <jurjanpaul@cq2.nl>
Date: Fri, 5 Oct 2012 17:13:01 +0200
Subject: [PATCH 03/11] JPM: optimized number of Berkeley dict syncs; TODO: write v2 to v3 conversion script

---
 meresco/oai/oaijazz.py |   25 ++++++++++++++++---------
 test/oaijazztest.py    |    7 +++----
 2 files changed, 19 insertions(+), 13 deletions(-)

diff --git a/meresco/oai/oaijazz.py b/meresco/oai/oaijazz.py
index b82eb1f..161039f 100644
--- a/meresco/oai/oaijazz.py
+++ b/meresco/oai/oaijazz.py
@@ -38,10 +38,11 @@ from bisect import bisect_left
 from time import time, strftime, gmtime, strptime
 from calendar import timegm
 from json import dumps, load as jsonLoad
+from bsddb import btopen
 
 from escaping import escapeFilename, unescapeFilename
 from meresco.components.sorteditertools import OrIterator, AndIterator
-from meresco.components import PersistentSortedIntegerList, DoubleUniqueBerkeleyDict, BerkeleyDict
+from meresco.components import PersistentSortedIntegerList
 from meresco.core import asyncreturn
 from weightless.io import Suspend
 
@@ -64,14 +65,12 @@ class OaiJazz(object):
         self._name = name
         self._suspended = []
 
-        self._stamp2identifier = DoubleUniqueBerkeleyDict(
-            _ensureDir(join(aDirectory, 'stamp2identifier')))
+        self._stamp2identifier = btopen(join(aDirectory, 'stamp2identifier.bd'))
         self._tombStones = PersistentSortedIntegerList(
             join(self._directory, 'tombStones.list'), 
             use64bits=True, 
             mergeTrigger=MERGE_TRIGGER)
-        self._identifier2setSpecs = BerkeleyDict(
-            _ensureDir(join(self._directory, 'identifier2setSpecs')))
+        self._identifier2setSpecs = btopen(join(self._directory, 'identifier2setSpecs.bd'))
         self._prefixesInfoDir = _ensureDir(join(aDirectory, 'prefixesInfo'))
         self._prefixesDir = _ensureDir(join(aDirectory, 'prefixes'))
         self._prefixes = {}
@@ -272,14 +271,22 @@ class OaiJazz(object):
             self._add(identifier, newStamp, prefixes, setSpecs)
             if delete:
                 self._tombStones.append(newStamp)
+        self._stamp2identifier.sync()
+        self._identifier2setSpecs.sync()
 
     def _purge(self, identifier, oldStamp):        
+        # TODO: cleanup ugliness
         _removeIfInList(oldStamp, self._tombStones)
         try:
             del self._stamp2identifier[str(oldStamp)]
         except KeyError:
             # already done apparently
             pass
+        try:
+            del self._stamp2identifier["id:" + identifier]
+        except KeyError:
+            # already done apparently
+            pass
         for prefix, prefixStamps in self._prefixes.items():
             _removeIfInList(oldStamp, prefixStamps)
         try:
@@ -301,6 +308,7 @@ class OaiJazz(object):
         if setSpecs:
             self._identifier2setSpecs[identifier] = SETSPEC_SEPARATOR.join(setSpecs) 
         self._stamp2identifier[str(newStamp)] = identifier
+        self._stamp2identifier["id:" + identifier] = str(newStamp)
         
     def _getAllMetadataFormats(self):
         for prefix in self._prefixes.keys():
@@ -331,12 +339,11 @@ class OaiJazz(object):
         except (ValueError, OverflowError):
             return maxint * DATESTAMP_FACTOR
 
-
     def _getIdentifier(self, stamp):
         return self._stamp2identifier.get(str(stamp), None)
 
     def _getStamp(self, identifier):
-        result = self._stamp2identifier.getKeyFor(safeString(identifier))
+        result = self._stamp2identifier.get("id:" + safeString(identifier), None)
         if result != None:
             result = int(result)
         return result
@@ -355,10 +362,10 @@ class OaiJazz(object):
 
     def _versionFormatCheck(self):
         if isdir(join(self._directory, 'sets')):
-            assert isdir(join(self._directory, 'identifier2setSpecs')), "This is an old OaiJazz data storage which doesn't have the identifier2setSpecs directory. Please convert manually or rebuild complete data storage."
+            assert isfile(join(self._directory, 'identifier2setSpecs.bd')), "This is an old OaiJazz data storage which doesn't have the identifier2setSpecs.bd file. Please convert manually or rebuild complete data storage."
 
         self._versionFile = join(self._directory, "oai.version")
-        assert listdir(self._directory) == [] or (isfile(self._versionFile) and open(self._versionFile).read() == self.version), "The OAI index at %s need to be converted to the current version (with 'convert_oai_v1_to_v2.py' in meresco-oai/bin)" % self._directory
+        assert listdir(self._directory) == [] or (isfile(self._versionFile) and open(self._versionFile).read() == self.version), "The OAI index at %s need to be converted to the current version (with 'convert_oai_v2_to_v3.py' in meresco-oai/bin)" % self._directory
         with open(join(self._directory, "oai.version"), 'w') as f:
             f.write(self.version)
 
diff --git a/test/oaijazztest.py b/test/oaijazztest.py
index b66bdbb..1bd66ce 100644
--- a/test/oaijazztest.py
+++ b/test/oaijazztest.py
@@ -35,7 +35,6 @@ from seecr.test import SeecrTestCase, CallTrace
 
 from os import listdir, remove
 from os.path import isfile, join
-from shutil import rmtree
 from time import time, strptime, sleep
 from calendar import timegm
 
@@ -326,7 +325,7 @@ class OaiJazzTest(SeecrTestCase):
 
     def testConversionNeeded(self):
         self.jazz.addOaiRecord('42', metadataFormats=[('prefix','schema', 'namespace')], sets=[('setSpec', 'setName')])
-        rmtree(join(self.tempdir, 'identifier2setSpecs'))
+        remove(join(self.tempdir, 'identifier2setSpecs.bd'))
         self.assertRaises(AssertionError, lambda: OaiJazz(self.tempdir))
 
     def testVersionWritten(self):
@@ -341,7 +340,7 @@ class OaiJazzTest(SeecrTestCase):
             oaiJazz = OaiJazz(self.tempdir)
             self.fail("Should have raised AssertionError with instruction of how to convert OAI index.")
         except AssertionError, e:
-            self.assertEquals("The OAI index at %s need to be converted to the current version (with 'convert_oai_v1_to_v2.py' in meresco-oai/bin)" % self.tempdir, str(e))
+            self.assertEquals("The OAI index at %s need to be converted to the current version (with 'convert_oai_v2_to_v3.py' in meresco-oai/bin)" % self.tempdir, str(e))
 
     def testRefuseInitWithDifferentVersionFile(self):
         self.oaiJazz = None
@@ -351,7 +350,7 @@ class OaiJazzTest(SeecrTestCase):
             oaiJazz = OaiJazz(self.tempdir)
             self.fail("Should have raised AssertionError with instruction of how to convert OAI index.")
         except AssertionError, e:
-            self.assertEquals("The OAI index at %s need to be converted to the current version (with 'convert_oai_v1_to_v2.py' in meresco-oai/bin)" % self.tempdir, str(e))
+            self.assertEquals("The OAI index at %s need to be converted to the current version (with 'convert_oai_v2_to_v3.py' in meresco-oai/bin)" % self.tempdir, str(e))
 
     def addDocuments(self, size):
         for id in range(1,size+1):
-- 
1.7.2.5


From ca0cb9994f69ea6b264cbd130ed4834f49fd8e5b Mon Sep 17 00:00:00 2001
From: Jurjan-Paul Medema <jurjanpaul@cq2.nl>
Date: Fri, 5 Oct 2012 21:57:55 +0200
Subject: [PATCH 04/11] JPM: only storing metadataFormats after _newStamp succeeds

---
 meresco/oai/oaijazz.py |   12 +++++++++---
 1 files changed, 9 insertions(+), 3 deletions(-)

diff --git a/meresco/oai/oaijazz.py b/meresco/oai/oaijazz.py
index 161039f..7bae492 100644
--- a/meresco/oai/oaijazz.py
+++ b/meresco/oai/oaijazz.py
@@ -94,15 +94,21 @@ class OaiJazz(object):
         assert [prefix for prefix, schema, namespace in metadataFormats], 'No metadataFormat specified for record with identifier "%s"' % identifier
         for setSpec, setName in sets:
             assert SETSPEC_SEPARATOR not in setSpec, 'SetSpec "%s" contains illegal characters' % setSpec
-        self._storeMetadataFormats(metadataFormats)
 
+        newStamp = self._newStamp()
+        self._storeMetadataFormats(metadataFormats)
         oldStamp, oldPrefixes, oldSets = self._lookupExisting(identifier)
         prefixes = set(prefix for prefix, schema, namespace in metadataFormats)
         prefixes.update(oldPrefixes)
         setSpecs = _flattenSetHierarchy((setSpec for setSpec, setName in sets))
         setSpecs.update(oldSets)
-
-        self._saveForRecoveryAndApply(identifier=identifier, oldStamp=oldStamp, newStamp=self._newStamp(), delete=False, prefixes=list(prefixes), setSpecs=list(setSpecs)) 
+        self._saveForRecoveryAndApply(
+            identifier=identifier, 
+            oldStamp=oldStamp, 
+            newStamp=newStamp, 
+            delete=False, 
+            prefixes=list(prefixes), 
+            setSpecs=list(setSpecs)) 
         self._resume()
 
     @asyncreturn
-- 
1.7.2.5


From 4fa4a3c1b1f6d10e876e0d1280c9b5f1945ff65e Mon Sep 17 00:00:00 2001
From: Jurjan-Paul Medema <jurjanpaul@cq2.nl>
Date: Mon, 8 Oct 2012 22:12:07 +0200
Subject: [PATCH 05/11] JPM: added first test with respect to recovery; fixed small issues, cleaned up code

---
 meresco/oai/oaijazz.py |   30 ++++++++++--------------------
 test/oaijazztest.py    |   32 ++++++++++++++++++++++++++++++++
 2 files changed, 42 insertions(+), 20 deletions(-)

diff --git a/meresco/oai/oaijazz.py b/meresco/oai/oaijazz.py
index 7bae492..46bd04c 100644
--- a/meresco/oai/oaijazz.py
+++ b/meresco/oai/oaijazz.py
@@ -143,6 +143,7 @@ class OaiJazz(object):
             newStamp=None) 
 
     def oaiSelect(self, sets=None, prefix='oai_dc', continueAfter='0', oaiFrom=None, oaiUntil=None, setsMask=None):
+        self._maybeRecover()
         setsMask = setsMask or []
         sets = sets or []
         start = max(int(continueAfter)+1, self._fromTime(oaiFrom))
@@ -266,41 +267,30 @@ class OaiJazz(object):
             remove(self._actionFile + '.tmp')
             return
         if isfile(self._actionFile):
-            action = jsonLoad(self._actionFile)
+            with open(self._actionFile, 'r') as f:
+                action = jsonLoad(f)
             self._applyAction(**action)
             remove(self._actionFile)
 
     def _applyAction(self, identifier, oldStamp=None, newStamp=None, delete=False, prefixes=None, setSpecs=None):
         if not oldStamp is None:
-            self._purge(identifier, oldStamp)
+            self._purge(safeString(identifier), oldStamp)
         if not newStamp is None:
-            self._add(identifier, newStamp, prefixes, setSpecs)
+            self._add(safeString(identifier), newStamp, prefixes, setSpecs)
             if delete:
                 self._tombStones.append(newStamp)
         self._stamp2identifier.sync()
         self._identifier2setSpecs.sync()
 
     def _purge(self, identifier, oldStamp):        
-        # TODO: cleanup ugliness
         _removeIfInList(oldStamp, self._tombStones)
-        try:
-            del self._stamp2identifier[str(oldStamp)]
-        except KeyError:
-            # already done apparently
-            pass
-        try:
-            del self._stamp2identifier["id:" + identifier]
-        except KeyError:
-            # already done apparently
-            pass
+        self._stamp2identifier.pop(str(oldStamp), None)
+        self._stamp2identifier.pop(str("id:" + identifier), None)
         for prefix, prefixStamps in self._prefixes.items():
             _removeIfInList(oldStamp, prefixStamps)
-        try:
-            oldSets = self._identifier2setSpecs[identifier].split(SETSPEC_SEPARATOR)
-        except KeyError:
-            # already done apparently
-            pass
-        else:
+        oldSets = self._identifier2setSpecs.get(identifier, None)
+        if not oldSets is None:
+            oldSets = oldSets.split(SETSPEC_SEPARATOR)
             for setSpec in oldSets:
                 _removeIfInList(oldStamp, self._sets[setSpec])
             del self._identifier2setSpecs[identifier]
diff --git a/test/oaijazztest.py b/test/oaijazztest.py
index 1bd66ce..dae192b 100644
--- a/test/oaijazztest.py
+++ b/test/oaijazztest.py
@@ -642,4 +642,36 @@ class OaiJazzTest(SeecrTestCase):
         self.assertEquals("", stamp2zulutime(None))
         self.assertRaises(Exception, stamp2zulutime, "not-a-stamp")
 
+    def testRecoverFromCrash(self):
+        identifier = 'oai://1234?34'
+        self.jazz.addOaiRecord(identifier=identifier, sets=[('A', 'set A')], metadataFormats=[('prefix', 'schema', 'namespace')])
+        self.assertFalse(isfile(self.jazz._actionFile))
+        def crash():
+            raise FullStopException("crashed")
+        self.jazz._stamp2identifier.sync = crash
+        try:
+            self.jazz.addOaiRecord(identifier=identifier, sets=[('B', 'set B')], metadataFormats=[('prefix2', 'schema2', 'namespace2')])
+            assert False
+        except FullStopException:
+            self.assertTrue(isfile(self.jazz._actionFile))
+        newJazz = OaiJazz(aDirectory=self.jazz._directory)
+        self.assertFalse(isfile(self.jazz._actionFile))
+        self.assertEquals(['A', 'B'], newJazz.getSets(identifier))
+        self.assertEquals(set(['prefix', 'prefix2']), set(newJazz.getPrefixes(identifier)))
+
+        # Should also test...
+        # combinations of...
+        # * delete
+        # * purge
+        # and recover from:
+        # * oaiAddRecord
+        # * delete
+        # * purge        
+        # * oaiSelect
+        #
+        # + crashing at all possible stages...
+        #
 
+        
+class FullStopException(Exception): pass
+        
-- 
1.7.2.5


From d1663e108e5f1a2b5e2f61b193c95a5c7045fc97 Mon Sep 17 00:00:00 2001
From: Jurjan-Paul Medema <jurjanpaul@cq2.nl>
Date: Mon, 8 Oct 2012 22:18:01 +0200
Subject: [PATCH 06/11] JPM: some little more cleaning up of OaiJazz._purge

---
 meresco/oai/oaijazz.py |    5 ++---
 1 files changed, 2 insertions(+), 3 deletions(-)

diff --git a/meresco/oai/oaijazz.py b/meresco/oai/oaijazz.py
index 46bd04c..a2dd429 100644
--- a/meresco/oai/oaijazz.py
+++ b/meresco/oai/oaijazz.py
@@ -288,10 +288,9 @@ class OaiJazz(object):
         self._stamp2identifier.pop(str("id:" + identifier), None)
         for prefix, prefixStamps in self._prefixes.items():
             _removeIfInList(oldStamp, prefixStamps)
-        oldSets = self._identifier2setSpecs.get(identifier, None)
+        oldSets = self._identifier2setSpecs.get(identifier)
         if not oldSets is None:
-            oldSets = oldSets.split(SETSPEC_SEPARATOR)
-            for setSpec in oldSets:
+            for setSpec in oldSets.split(SETSPEC_SEPARATOR):
                 _removeIfInList(oldStamp, self._sets[setSpec])
             del self._identifier2setSpecs[identifier]
 
-- 
1.7.2.5


From 96e312d2d6f172b947d64b3b601506ba1a29e77d Mon Sep 17 00:00:00 2001
From: Jurjan-Paul Medema <jurjanpaul@cq2.nl>
Date: Wed, 10 Oct 2012 08:41:26 +0200
Subject: [PATCH 07/11] JPM: made explicit distinction between process crash and failure while running

---
 meresco/oai/oaijazz.py |   58 ++++++++++++++++++++++++++++-------------------
 test/oaijazztest.py    |    9 +++++--
 2 files changed, 40 insertions(+), 27 deletions(-)

diff --git a/meresco/oai/oaijazz.py b/meresco/oai/oaijazz.py
index a2dd429..374a283 100644
--- a/meresco/oai/oaijazz.py
+++ b/meresco/oai/oaijazz.py
@@ -76,8 +76,9 @@ class OaiJazz(object):
         self._prefixes = {}
         self._setsDir = _ensureDir(join(aDirectory, 'sets'))
         self._sets = {}
-        self._actionFile = join(self._directory, 'action.json')
         self._newestStamp = 0
+        self._hasUnfinishedChange = False
+        self._changeFile = join(self._directory, 'change.json')
         self._read()
         self._maybeRecover()
 
@@ -85,7 +86,7 @@ class OaiJazz(object):
         return self._name
 
     def addOaiRecord(self, identifier, sets=None, metadataFormats=None):
-        self._maybeRecover()
+        self._maybeFinishChange()
         if not identifier:
             raise ValueError("Empty identifier not allowed.")
         identifier = safeString(identifier)
@@ -113,7 +114,7 @@ class OaiJazz(object):
 
     @asyncreturn
     def delete(self, identifier):
-        self._maybeRecover()
+        self._maybeFinishChange()
         if not identifier:
             raise ValueError("Empty identifier not allowed.")
         identifier = safeString(identifier)
@@ -130,7 +131,7 @@ class OaiJazz(object):
         self._resume()
 
     def purge(self, identifier):
-        self._maybeRecover()
+        self._maybeFinishChange()
         if self._persistentDelete:
             raise KeyError("Purging of records is not allowed with persistent deletes.")
         identifier = safeString(identifier)
@@ -143,7 +144,7 @@ class OaiJazz(object):
             newStamp=None) 
 
     def oaiSelect(self, sets=None, prefix='oai_dc', continueAfter='0', oaiFrom=None, oaiUntil=None, setsMask=None):
-        self._maybeRecover()
+        self._maybeFinishChange()
         setsMask = setsMask or []
         sets = sets or []
         start = max(int(continueAfter)+1, self._fromTime(oaiFrom))
@@ -169,6 +170,7 @@ class OaiJazz(object):
         return _stamp2zulutime(stamp=stamp, preciseDatestamp=self._preciseDatestamp)
 
     def getUnique(self, identifier):
+        self._maybeFinishChange()
         if hasattr(identifier, 'stamp'):
             return identifier.stamp
         return self._getStamp(identifier)
@@ -180,12 +182,17 @@ class OaiJazz(object):
         return stamp in self._tombStones
 
     def getAllMetadataFormats(self):
-        return self._getAllMetadataFormats()
+        for prefix in self._prefixes.keys():
+            schema = open(join(self._prefixesInfoDir, '%s.schema' % escapeFilename(prefix))).read()
+            namespace = open(join(self._prefixesInfoDir, '%s.namespace' % escapeFilename(prefix))).read()
+            yield (prefix, schema, namespace)
 
     def getAllPrefixes(self):
+        self._maybeFinishChange()
         return self._prefixes.keys()
 
     def getSets(self, identifier):
+        self._maybeFinishChange()
         identifier = safeString(identifier)
         if identifier not in self._identifier2setSpecs:
             return []
@@ -198,12 +205,15 @@ class OaiJazz(object):
         return (prefix for prefix, stampIds in self._prefixes.items() if stamp in stampIds)
 
     def getAllSets(self):
+        self._maybeFinishChange()
         return self._sets.keys()
         
     def getNrOfRecords(self, prefix='oai_dc'):
+        self._maybeFinishChange()
         return len(self._prefixes.get(prefix, []))
 
     def getLastStampId(self, prefix='oai_dc'):
+        self._maybeFinishChange()
         if prefix in self._prefixes and self._prefixes[prefix]:
             stampIds = self._prefixes[prefix]
             return stampIds[-1] if stampIds else None
@@ -258,21 +268,26 @@ class OaiJazz(object):
         return stamp, oldPrefixes, oldSets
 
     def _saveForRecoveryAndApply(self, **kwargs):
-        _write(self._actionFile, dumps(kwargs))
-        self._applyAction(**kwargs)
-        remove(self._actionFile)
+        _write(self._changeFile, dumps(kwargs))
+        self._applyChange(**kwargs)
+        remove(self._changeFile)
+
+    def _maybeFinishChange(self):
+        if self._hasUnfinishedChange:
+            self._maybeRecover()
 
     def _maybeRecover(self):
-        if isfile(self._actionFile + '.tmp'):
-            remove(self._actionFile + '.tmp')
+        if isfile(self._changeFile + '.tmp'):
+            remove(self._changeFile + '.tmp')
             return
-        if isfile(self._actionFile):
-            with open(self._actionFile, 'r') as f:
-                action = jsonLoad(f)
-            self._applyAction(**action)
-            remove(self._actionFile)
-
-    def _applyAction(self, identifier, oldStamp=None, newStamp=None, delete=False, prefixes=None, setSpecs=None):
+        if isfile(self._changeFile):
+            with open(self._changeFile, 'r') as f:
+                change = jsonLoad(f)
+            self._applyChange(**change)
+            remove(self._changeFile)
+
+    def _applyChange(self, identifier, oldStamp=None, newStamp=None, delete=False, prefixes=None, setSpecs=None):
+        self._hasUnfinishedChange = True
         if not oldStamp is None:
             self._purge(safeString(identifier), oldStamp)
         if not newStamp is None:
@@ -281,6 +296,7 @@ class OaiJazz(object):
                 self._tombStones.append(newStamp)
         self._stamp2identifier.sync()
         self._identifier2setSpecs.sync()
+        self._hasUnfinishedChange = False
 
     def _purge(self, identifier, oldStamp):        
         _removeIfInList(oldStamp, self._tombStones)
@@ -305,12 +321,6 @@ class OaiJazz(object):
         self._stamp2identifier[str(newStamp)] = identifier
         self._stamp2identifier["id:" + identifier] = str(newStamp)
         
-    def _getAllMetadataFormats(self):
-        for prefix in self._prefixes.keys():
-            schema = open(join(self._prefixesInfoDir, '%s.schema' % escapeFilename(prefix))).read()
-            namespace = open(join(self._prefixesInfoDir, '%s.namespace' % escapeFilename(prefix))).read()
-            yield (prefix, schema, namespace)
-
     def _sliceStampIds(self, stampIds, start, stop):
         if stop:
             return stampIds[bisect_left(stampIds, start):bisect_left(stampIds, stop)]
diff --git a/test/oaijazztest.py b/test/oaijazztest.py
index dae192b..4e5eb05 100644
--- a/test/oaijazztest.py
+++ b/test/oaijazztest.py
@@ -645,7 +645,8 @@ class OaiJazzTest(SeecrTestCase):
     def testRecoverFromCrash(self):
         identifier = 'oai://1234?34'
         self.jazz.addOaiRecord(identifier=identifier, sets=[('A', 'set A')], metadataFormats=[('prefix', 'schema', 'namespace')])
-        self.assertFalse(isfile(self.jazz._actionFile))
+        self.assertFalse(self.jazz._hasUnfinishedChange)
+        self.assertFalse(isfile(self.jazz._changeFile))
         def crash():
             raise FullStopException("crashed")
         self.jazz._stamp2identifier.sync = crash
@@ -653,9 +654,11 @@ class OaiJazzTest(SeecrTestCase):
             self.jazz.addOaiRecord(identifier=identifier, sets=[('B', 'set B')], metadataFormats=[('prefix2', 'schema2', 'namespace2')])
             assert False
         except FullStopException:
-            self.assertTrue(isfile(self.jazz._actionFile))
+            self.assertTrue(self.jazz._hasUnfinishedChange)
+            self.assertTrue(isfile(self.jazz._changeFile))
         newJazz = OaiJazz(aDirectory=self.jazz._directory)
-        self.assertFalse(isfile(self.jazz._actionFile))
+        self.assertFalse(isfile(self.jazz._changeFile))
+        self.assertFalse(newJazz._hasUnfinishedChange)
         self.assertEquals(['A', 'B'], newJazz.getSets(identifier))
         self.assertEquals(set(['prefix', 'prefix2']), set(newJazz.getPrefixes(identifier)))
 
-- 
1.7.2.5


From 579299ee84edea063516975e8bf9c26686daaa41 Mon Sep 17 00:00:00 2001
From: Jurjan-Paul Medema <jurjanpaul@cq2.nl>
Date: Wed, 10 Oct 2012 14:57:51 +0200
Subject: [PATCH 08/11] JPM: improved crash recovery testing; oldSets in change.json to depend even less on order within _purge;

---
 meresco/oai/oaijazz.py |  108 +++++++++++++++++++++++++----------------------
 test/oaijazztest.py    |   84 +++++++++++++++++++++++++++----------
 2 files changed, 119 insertions(+), 73 deletions(-)

diff --git a/meresco/oai/oaijazz.py b/meresco/oai/oaijazz.py
index 374a283..fbfa91b 100644
--- a/meresco/oai/oaijazz.py
+++ b/meresco/oai/oaijazz.py
@@ -86,7 +86,7 @@ class OaiJazz(object):
         return self._name
 
     def addOaiRecord(self, identifier, sets=None, metadataFormats=None):
-        self._maybeFinishChange()
+        self._completeUnfinishedChange()
         if not identifier:
             raise ValueError("Empty identifier not allowed.")
         identifier = safeString(identifier)
@@ -106,15 +106,16 @@ class OaiJazz(object):
         self._saveForRecoveryAndApply(
             identifier=identifier, 
             oldStamp=oldStamp, 
+            oldSets=list(oldSets),
             newStamp=newStamp, 
             delete=False, 
             prefixes=list(prefixes), 
-            setSpecs=list(setSpecs)) 
+            newSets=list(setSpecs)) 
         self._resume()
 
     @asyncreturn
     def delete(self, identifier):
-        self._maybeFinishChange()
+        self._completeUnfinishedChange()
         if not identifier:
             raise ValueError("Empty identifier not allowed.")
         identifier = safeString(identifier)
@@ -123,15 +124,16 @@ class OaiJazz(object):
             return
         self._saveForRecoveryAndApply(
             identifier=identifier, 
-            oldStamp=oldStamp, 
+            oldStamp=oldStamp,
+            oldSets=list(oldSets), 
             newStamp=self._newStamp(), 
             delete=True, 
             prefixes=list(set(oldPrefixes + self._deletePrefixes)), 
-            setSpecs=list(oldSets))
+            newSets=list(oldSets))
         self._resume()
 
     def purge(self, identifier):
-        self._maybeFinishChange()
+        self._completeUnfinishedChange()
         if self._persistentDelete:
             raise KeyError("Purging of records is not allowed with persistent deletes.")
         identifier = safeString(identifier)
@@ -140,11 +142,12 @@ class OaiJazz(object):
             return
         self._saveForRecoveryAndApply(
             identifier=identifier, 
-            oldStamp=oldStamp, 
+            oldStamp=oldStamp,
+            oldSets=list(oldSets), 
             newStamp=None) 
 
     def oaiSelect(self, sets=None, prefix='oai_dc', continueAfter='0', oaiFrom=None, oaiUntil=None, setsMask=None):
-        self._maybeFinishChange()
+        self._completeUnfinishedChange()
         setsMask = setsMask or []
         sets = sets or []
         start = max(int(continueAfter)+1, self._fromTime(oaiFrom))
@@ -170,7 +173,7 @@ class OaiJazz(object):
         return _stamp2zulutime(stamp=stamp, preciseDatestamp=self._preciseDatestamp)
 
     def getUnique(self, identifier):
-        self._maybeFinishChange()
+        self._completeUnfinishedChange()
         if hasattr(identifier, 'stamp'):
             return identifier.stamp
         return self._getStamp(identifier)
@@ -188,11 +191,11 @@ class OaiJazz(object):
             yield (prefix, schema, namespace)
 
     def getAllPrefixes(self):
-        self._maybeFinishChange()
+        self._completeUnfinishedChange()
         return self._prefixes.keys()
 
     def getSets(self, identifier):
-        self._maybeFinishChange()
+        self._completeUnfinishedChange()
         identifier = safeString(identifier)
         if identifier not in self._identifier2setSpecs:
             return []
@@ -205,15 +208,15 @@ class OaiJazz(object):
         return (prefix for prefix, stampIds in self._prefixes.items() if stamp in stampIds)
 
     def getAllSets(self):
-        self._maybeFinishChange()
+        self._completeUnfinishedChange()
         return self._sets.keys()
         
     def getNrOfRecords(self, prefix='oai_dc'):
-        self._maybeFinishChange()
+        self._completeUnfinishedChange()
         return len(self._prefixes.get(prefix, []))
 
     def getLastStampId(self, prefix='oai_dc'):
-        self._maybeFinishChange()
+        self._completeUnfinishedChange()
         if prefix in self._prefixes and self._prefixes[prefix]:
             stampIds = self._prefixes[prefix]
             return stampIds[-1] if stampIds else None
@@ -272,54 +275,56 @@ class OaiJazz(object):
         self._applyChange(**kwargs)
         remove(self._changeFile)
 
-    def _maybeFinishChange(self):
+    def _completeUnfinishedChange(self):
         if self._hasUnfinishedChange:
-            self._maybeRecover()
+            self._recover()
+            self._resume()
 
     def _maybeRecover(self):
         if isfile(self._changeFile + '.tmp'):
             remove(self._changeFile + '.tmp')
-            return
         if isfile(self._changeFile):
-            with open(self._changeFile, 'r') as f:
-                change = jsonLoad(f)
-            self._applyChange(**change)
-            remove(self._changeFile)
+            self._recover()
+
+    def _recover(self):            
+        with open(self._changeFile, 'r') as f:
+            change = jsonLoad(f)
+        self._applyChange(**change)
+        remove(self._changeFile)
 
-    def _applyChange(self, identifier, oldStamp=None, newStamp=None, delete=False, prefixes=None, setSpecs=None):
+    def _applyChange(self, identifier, oldStamp=None, oldSets=None, newStamp=None, delete=False, prefixes=None, newSets=None):
+        identifier = safeString(identifier)
         self._hasUnfinishedChange = True
         if not oldStamp is None:
-            self._purge(safeString(identifier), oldStamp)
+            self._purge(identifier, oldStamp, oldSets)
         if not newStamp is None:
-            self._add(safeString(identifier), newStamp, prefixes, setSpecs)
+            self._add(identifier, newStamp, prefixes, newSets)
             if delete:
-                self._tombStones.append(newStamp)
+                self._appendIfNotYet(newStamp, self._tombStones)
         self._stamp2identifier.sync()
         self._identifier2setSpecs.sync()
         self._hasUnfinishedChange = False
 
-    def _purge(self, identifier, oldStamp):        
-        _removeIfInList(oldStamp, self._tombStones)
+    def _purge(self, identifier, oldStamp, oldSets):
         self._stamp2identifier.pop(str(oldStamp), None)
         self._stamp2identifier.pop(str("id:" + identifier), None)
+        self._removeIfInList(oldStamp, self._tombStones)
         for prefix, prefixStamps in self._prefixes.items():
-            _removeIfInList(oldStamp, prefixStamps)
-        oldSets = self._identifier2setSpecs.get(identifier)
-        if not oldSets is None:
-            for setSpec in oldSets.split(SETSPEC_SEPARATOR):
-                _removeIfInList(oldStamp, self._sets[setSpec])
-            del self._identifier2setSpecs[identifier]
-
-    def _add(self, identifier, newStamp, prefixes, setSpecs):
+            self._removeIfInList(oldStamp, prefixStamps)
+        self._identifier2setSpecs.pop(identifier, None)
+        for setSpec in oldSets:
+            self._removeIfInList(oldStamp, self._sets[setSpec])
+
+    def _add(self, identifier, newStamp, prefixes, newSets):
         self._newestStamp = newStamp
-        for prefix in prefixes:
-            _appendIfNotYet(newStamp, self._getPrefixList(prefix))
-        for setSpec in setSpecs:
-            _appendIfNotYet(newStamp, self._getSetList(setSpec))
-        if setSpecs:
-            self._identifier2setSpecs[identifier] = SETSPEC_SEPARATOR.join(setSpecs) 
         self._stamp2identifier[str(newStamp)] = identifier
         self._stamp2identifier["id:" + identifier] = str(newStamp)
+        for prefix in prefixes:
+            self._appendIfNotYet(newStamp, self._getPrefixList(prefix))
+        for setSpec in newSets:
+            self._appendIfNotYet(newStamp, self._getSetList(setSpec))
+        if newSets:
+            self._identifier2setSpecs[identifier] = SETSPEC_SEPARATOR.join(newSets)
         
     def _sliceStampIds(self, stampIds, start, stop):
         if stop:
@@ -378,6 +383,17 @@ class OaiJazz(object):
         while len(self._suspended) > 0:
             self._suspended.pop().resume()
 
+    def _removeIfInList(self, item, l):
+        try:
+            l.remove(item)
+        except ValueError:
+            pass
+
+    def _appendIfNotYet(self, item, l):
+        if len(l) == 0 or l[-1] != item:
+            l.append(item)
+
+
 # helper methods
 
 class RecordId(str):
@@ -424,13 +440,3 @@ def _ensureDir(directory):
     isdir(directory) or makedirs(directory) 
     return directory
 
-def _removeIfInList(item, l):
-    try:
-        l.remove(item)
-    except ValueError:
-        pass
-
-def _appendIfNotYet(item, l):
-    if len(l) == 0 or l[-1] != item:
-        l.append(item)
-
diff --git a/test/oaijazztest.py b/test/oaijazztest.py
index 4e5eb05..eb69253 100644
--- a/test/oaijazztest.py
+++ b/test/oaijazztest.py
@@ -642,26 +642,47 @@ class OaiJazzTest(SeecrTestCase):
         self.assertEquals("", stamp2zulutime(None))
         self.assertRaises(Exception, stamp2zulutime, "not-a-stamp")
 
-    def testRecoverFromCrash(self):
+    def testRecoverFromCrashAtAnyStep(self):
         identifier = 'oai://1234?34'
-        self.jazz.addOaiRecord(identifier=identifier, sets=[('A', 'set A')], metadataFormats=[('prefix', 'schema', 'namespace')])
-        self.assertFalse(self.jazz._hasUnfinishedChange)
-        self.assertFalse(isfile(self.jazz._changeFile))
-        def crash():
-            raise FullStopException("crashed")
-        self.jazz._stamp2identifier.sync = crash
-        try:
-            self.jazz.addOaiRecord(identifier=identifier, sets=[('B', 'set B')], metadataFormats=[('prefix2', 'schema2', 'namespace2')])
-            assert False
-        except FullStopException:
-            self.assertTrue(self.jazz._hasUnfinishedChange)
-            self.assertTrue(isfile(self.jazz._changeFile))
-        newJazz = OaiJazz(aDirectory=self.jazz._directory)
-        self.assertFalse(isfile(self.jazz._changeFile))
-        self.assertFalse(newJazz._hasUnfinishedChange)
-        self.assertEquals(['A', 'B'], newJazz.getSets(identifier))
-        self.assertEquals(set(['prefix', 'prefix2']), set(newJazz.getPrefixes(identifier)))
-
+       
+        for crashingStep in range(1, 15):
+            crashingJazz = OaiJazz(self.tempdir)
+            crashingJazz.addOaiRecord(identifier=identifier, sets=[('A', 'set A')], metadataFormats=[('prefix', 'schema', 'namespace')])
+            self.assertFalse(crashingJazz._hasUnfinishedChange)
+            self.assertFalse(isfile(crashingJazz._changeFile))
+
+            stepCount = [0]
+            def replaceMethodWithCrashAtStep(object, methodName):
+                original = getattr(object, methodName)
+                def crashAtStep(*args, **kwargs):
+                    stepCount[0] += 1
+                    if stepCount[0] == crashingStep:
+                        raise RuntimeError("crash in '%s' of %s@%s for args %s and kwargs %s" % (methodName, object.__class__.__name__, id(object), args, kwargs))
+                    original(*args, **kwargs)
+                setattr(object, methodName, crashAtStep)
+
+            replaceMethodWithCrashAtStep(crashingJazz, '_removeIfInList')
+            replaceMethodWithCrashAtStep(crashingJazz, '_appendIfNotYet')
+            replaceMethodWithCrashAtStep(crashingJazz._stamp2identifier, 'sync')
+            replaceMethodWithCrashAtStep(crashingJazz._identifier2setSpecs, 'sync')
+
+            try:
+                crashingJazz.addOaiRecord(identifier=identifier, sets=[('B', 'set B')], metadataFormats=[('prefix2', 'schema2', 'namespace2')])
+                # not crashed...
+                self.assertEquals(['A', 'B'], crashingJazz.getSets(identifier))
+                self.assertEquals(set(['prefix', 'prefix2']), set(crashingJazz.getPrefixes(identifier)))
+            except RuntimeError, e:
+                self.assertTrue(crashingJazz._hasUnfinishedChange)
+                self.assertTrue(isfile(crashingJazz._changeFile))
+                crashingJazz = None
+
+            # recover
+            newJazz = OaiJazz(aDirectory=self.tempdir)
+            self.assertFalse(isfile(newJazz._changeFile))
+            self.assertFalse(newJazz._hasUnfinishedChange)
+            self.assertEquals(['A', 'B'], newJazz.getSets(identifier))
+            self.assertEquals(set(['prefix', 'prefix2']), set(newJazz.getPrefixes(identifier)))
+        
         # Should also test...
         # combinations of...
         # * delete
@@ -675,6 +696,25 @@ class OaiJazzTest(SeecrTestCase):
         # + crashing at all possible stages...
         #
 
-        
-class FullStopException(Exception): pass
-        
+    def testRecoverFromExceptionInApplyChange(self):
+        identifier = 'oai://1234?34'
+        self.jazz.addOaiRecord(identifier=identifier, sets=[('A', 'set A')], metadataFormats=[('prefix', 'schema', 'namespace')])
+        self.assertFalse(self.jazz._hasUnfinishedChange)
+        self.assertFalse(isfile(self.jazz._changeFile))
+        def raiseException():
+            raise RuntimeError("some exception")
+        originalSync = self.jazz._stamp2identifier.sync
+        self.jazz._stamp2identifier.sync = raiseException
+        try:
+            self.jazz.addOaiRecord(identifier=identifier, sets=[('B', 'set B')], metadataFormats=[('prefix2', 'schema2', 'namespace2')])
+            assert False
+        except RuntimeError:
+            self.assertTrue(self.jazz._hasUnfinishedChange)
+            self.assertTrue(isfile(self.jazz._changeFile))
+
+        self.jazz._stamp2identifier.sync = originalSync 
+        self.assertEquals(['A', 'B'], self.jazz.getSets(identifier))
+        self.assertFalse(isfile(self.jazz._changeFile))
+        self.assertFalse(self.jazz._hasUnfinishedChange)
+        self.assertEquals(set(['prefix', 'prefix2']), set(self.jazz.getPrefixes(identifier)))
+
-- 
1.7.2.5


From 9588e52e24d3e3b46eaf3892415e265714b923ff Mon Sep 17 00:00:00 2001
From: Jurjan-Paul Medema <jurjanpaul@cq2.nl>
Date: Wed, 10 Oct 2012 16:25:55 +0200
Subject: [PATCH 09/11] HM/JPM: SystemExit on exception in '_applyChange' makes everything so much easier;
 added testRecoverFromCrashingDelete and testRecoverFromCrashingPurge

---
 meresco/oai/oaijazz.py |   51 +++++++++----------------
 test/oaijazztest.py    |   97 ++++++++++++++++++++++++-----------------------
 2 files changed, 68 insertions(+), 80 deletions(-)

diff --git a/meresco/oai/oaijazz.py b/meresco/oai/oaijazz.py
index fbfa91b..e6d0046 100644
--- a/meresco/oai/oaijazz.py
+++ b/meresco/oai/oaijazz.py
@@ -39,6 +39,7 @@ from time import time, strftime, gmtime, strptime
 from calendar import timegm
 from json import dumps, load as jsonLoad
 from bsddb import btopen
+from traceback import print_exc
 
 from escaping import escapeFilename, unescapeFilename
 from meresco.components.sorteditertools import OrIterator, AndIterator
@@ -77,7 +78,6 @@ class OaiJazz(object):
         self._setsDir = _ensureDir(join(aDirectory, 'sets'))
         self._sets = {}
         self._newestStamp = 0
-        self._hasUnfinishedChange = False
         self._changeFile = join(self._directory, 'change.json')
         self._read()
         self._maybeRecover()
@@ -86,7 +86,6 @@ class OaiJazz(object):
         return self._name
 
     def addOaiRecord(self, identifier, sets=None, metadataFormats=None):
-        self._completeUnfinishedChange()
         if not identifier:
             raise ValueError("Empty identifier not allowed.")
         identifier = safeString(identifier)
@@ -115,7 +114,6 @@ class OaiJazz(object):
 
     @asyncreturn
     def delete(self, identifier):
-        self._completeUnfinishedChange()
         if not identifier:
             raise ValueError("Empty identifier not allowed.")
         identifier = safeString(identifier)
@@ -133,7 +131,6 @@ class OaiJazz(object):
         self._resume()
 
     def purge(self, identifier):
-        self._completeUnfinishedChange()
         if self._persistentDelete:
             raise KeyError("Purging of records is not allowed with persistent deletes.")
         identifier = safeString(identifier)
@@ -147,7 +144,6 @@ class OaiJazz(object):
             newStamp=None) 
 
     def oaiSelect(self, sets=None, prefix='oai_dc', continueAfter='0', oaiFrom=None, oaiUntil=None, setsMask=None):
-        self._completeUnfinishedChange()
         setsMask = setsMask or []
         sets = sets or []
         start = max(int(continueAfter)+1, self._fromTime(oaiFrom))
@@ -173,7 +169,6 @@ class OaiJazz(object):
         return _stamp2zulutime(stamp=stamp, preciseDatestamp=self._preciseDatestamp)
 
     def getUnique(self, identifier):
-        self._completeUnfinishedChange()
         if hasattr(identifier, 'stamp'):
             return identifier.stamp
         return self._getStamp(identifier)
@@ -191,11 +186,9 @@ class OaiJazz(object):
             yield (prefix, schema, namespace)
 
     def getAllPrefixes(self):
-        self._completeUnfinishedChange()
         return self._prefixes.keys()
 
     def getSets(self, identifier):
-        self._completeUnfinishedChange()
         identifier = safeString(identifier)
         if identifier not in self._identifier2setSpecs:
             return []
@@ -208,15 +201,12 @@ class OaiJazz(object):
         return (prefix for prefix, stampIds in self._prefixes.items() if stamp in stampIds)
 
     def getAllSets(self):
-        self._completeUnfinishedChange()
         return self._sets.keys()
         
     def getNrOfRecords(self, prefix='oai_dc'):
-        self._completeUnfinishedChange()
         return len(self._prefixes.get(prefix, []))
 
     def getLastStampId(self, prefix='oai_dc'):
-        self._completeUnfinishedChange()
         if prefix in self._prefixes and self._prefixes[prefix]:
             stampIds = self._prefixes[prefix]
             return stampIds[-1] if stampIds else None
@@ -275,35 +265,30 @@ class OaiJazz(object):
         self._applyChange(**kwargs)
         remove(self._changeFile)
 
-    def _completeUnfinishedChange(self):
-        if self._hasUnfinishedChange:
-            self._recover()
-            self._resume()
-
     def _maybeRecover(self):
         if isfile(self._changeFile + '.tmp'):
             remove(self._changeFile + '.tmp')
+            return
         if isfile(self._changeFile):
-            self._recover()
-
-    def _recover(self):            
-        with open(self._changeFile, 'r') as f:
-            change = jsonLoad(f)
-        self._applyChange(**change)
-        remove(self._changeFile)
+            with open(self._changeFile, 'r') as f:
+                change = jsonLoad(f)
+            self._applyChange(**change)
+            remove(self._changeFile)
 
     def _applyChange(self, identifier, oldStamp=None, oldSets=None, newStamp=None, delete=False, prefixes=None, newSets=None):
         identifier = safeString(identifier)
-        self._hasUnfinishedChange = True
-        if not oldStamp is None:
-            self._purge(identifier, oldStamp, oldSets)
-        if not newStamp is None:
-            self._add(identifier, newStamp, prefixes, newSets)
-            if delete:
-                self._appendIfNotYet(newStamp, self._tombStones)
-        self._stamp2identifier.sync()
-        self._identifier2setSpecs.sync()
-        self._hasUnfinishedChange = False
+        try:
+            if not oldStamp is None:
+                self._purge(identifier, oldStamp, oldSets)
+            if not newStamp is None:
+                self._add(identifier, newStamp, prefixes, newSets)
+                if delete:
+                    self._appendIfNotYet(newStamp, self._tombStones)
+            self._stamp2identifier.sync()
+            self._identifier2setSpecs.sync()
+        except:
+            print_exc()
+            raise SystemExit()
 
     def _purge(self, identifier, oldStamp, oldSets):
         self._stamp2identifier.pop(str(oldStamp), None)
diff --git a/test/oaijazztest.py b/test/oaijazztest.py
index eb69253..7c1b009 100644
--- a/test/oaijazztest.py
+++ b/test/oaijazztest.py
@@ -32,6 +32,7 @@
 ## end license ##
 
 from seecr.test import SeecrTestCase, CallTrace
+from seecr.test.io import stderr_replaced
 
 from os import listdir, remove
 from os.path import isfile, join
@@ -642,13 +643,53 @@ class OaiJazzTest(SeecrTestCase):
         self.assertEquals("", stamp2zulutime(None))
         self.assertRaises(Exception, stamp2zulutime, "not-a-stamp")
 
-    def testRecoverFromCrashAtAnyStep(self):
+    def testRecoverFromCrashingAddOaiRecord(self):
         identifier = 'oai://1234?34'
-       
+        def setUp(jazz):
+            jazz.addOaiRecord(identifier=identifier, sets=[('A', 'set A')], metadataFormats=[('prefix', 'schema', 'namespace')])
+
+        def modify(jazz):
+            jazz.addOaiRecord(identifier=identifier, sets=[('B', 'set B')], metadataFormats=[('prefix2', 'schema2', 'namespace2')])
+
+        def asserts(jazz):
+            self.assertEquals(['A', 'B'], jazz.getSets(identifier))
+            self.assertEquals(set(['prefix', 'prefix2']), set(jazz.getPrefixes(identifier)))
+
+        self._crashAtDifferentSteps(setUp, modify, asserts)
+
+    def testRecoverFromCrashingDelete(self):
+        identifier = 'oai://1234?34'
+        def setUp(jazz):
+            jazz.addOaiRecord(identifier=identifier, sets=[('A', 'set A')], metadataFormats=[('prefix', 'schema', 'namespace')])
+
+        def modify(jazz):
+            list(compose(jazz.delete(identifier)))
+
+        def asserts(jazz):
+            self.assertEquals(['A'], jazz.getSets(identifier))
+            self.assertEquals(set(['prefix']), set(jazz.getPrefixes(identifier)))
+            self.assertTrue(jazz.isDeleted(identifier))
+
+        self._crashAtDifferentSteps(setUp, modify, asserts)
+
+    def testRecoverFromCrashingPurge(self):
+        identifier = 'oai://1234?34'
+        def setUp(jazz):
+            jazz._persistentDelete = False
+            jazz.addOaiRecord(identifier=identifier, sets=[('A', 'set A')], metadataFormats=[('prefix', 'schema', 'namespace')])
+
+        def modify(jazz):
+            jazz.purge(identifier)
+
+        def asserts(jazz):
+            self.assertEquals(None, jazz.getUnique(identifier))
+
+        self._crashAtDifferentSteps(setUp, modify, asserts)
+        
+    def _crashAtDifferentSteps(self, setUp, modify, asserts):
         for crashingStep in range(1, 15):
             crashingJazz = OaiJazz(self.tempdir)
-            crashingJazz.addOaiRecord(identifier=identifier, sets=[('A', 'set A')], metadataFormats=[('prefix', 'schema', 'namespace')])
-            self.assertFalse(crashingJazz._hasUnfinishedChange)
+            setUp(crashingJazz)
             self.assertFalse(isfile(crashingJazz._changeFile))
 
             stepCount = [0]
@@ -667,54 +708,16 @@ class OaiJazzTest(SeecrTestCase):
             replaceMethodWithCrashAtStep(crashingJazz._identifier2setSpecs, 'sync')
 
             try:
-                crashingJazz.addOaiRecord(identifier=identifier, sets=[('B', 'set B')], metadataFormats=[('prefix2', 'schema2', 'namespace2')])
+                with stderr_replaced():
+                    modify(crashingJazz)
                 # not crashed...
-                self.assertEquals(['A', 'B'], crashingJazz.getSets(identifier))
-                self.assertEquals(set(['prefix', 'prefix2']), set(crashingJazz.getPrefixes(identifier)))
-            except RuntimeError, e:
-                self.assertTrue(crashingJazz._hasUnfinishedChange)
+                asserts(crashingJazz)
+            except SystemExit:
                 self.assertTrue(isfile(crashingJazz._changeFile))
                 crashingJazz = None
 
             # recover
             newJazz = OaiJazz(aDirectory=self.tempdir)
             self.assertFalse(isfile(newJazz._changeFile))
-            self.assertFalse(newJazz._hasUnfinishedChange)
-            self.assertEquals(['A', 'B'], newJazz.getSets(identifier))
-            self.assertEquals(set(['prefix', 'prefix2']), set(newJazz.getPrefixes(identifier)))
-        
-        # Should also test...
-        # combinations of...
-        # * delete
-        # * purge
-        # and recover from:
-        # * oaiAddRecord
-        # * delete
-        # * purge        
-        # * oaiSelect
-        #
-        # + crashing at all possible stages...
-        #
-
-    def testRecoverFromExceptionInApplyChange(self):
-        identifier = 'oai://1234?34'
-        self.jazz.addOaiRecord(identifier=identifier, sets=[('A', 'set A')], metadataFormats=[('prefix', 'schema', 'namespace')])
-        self.assertFalse(self.jazz._hasUnfinishedChange)
-        self.assertFalse(isfile(self.jazz._changeFile))
-        def raiseException():
-            raise RuntimeError("some exception")
-        originalSync = self.jazz._stamp2identifier.sync
-        self.jazz._stamp2identifier.sync = raiseException
-        try:
-            self.jazz.addOaiRecord(identifier=identifier, sets=[('B', 'set B')], metadataFormats=[('prefix2', 'schema2', 'namespace2')])
-            assert False
-        except RuntimeError:
-            self.assertTrue(self.jazz._hasUnfinishedChange)
-            self.assertTrue(isfile(self.jazz._changeFile))
-
-        self.jazz._stamp2identifier.sync = originalSync 
-        self.assertEquals(['A', 'B'], self.jazz.getSets(identifier))
-        self.assertFalse(isfile(self.jazz._changeFile))
-        self.assertFalse(self.jazz._hasUnfinishedChange)
-        self.assertEquals(set(['prefix', 'prefix2']), set(self.jazz.getPrefixes(identifier)))
+            asserts(newJazz)
 
-- 
1.7.2.5


From bbd9d134153d5f55ff43345fc7a9232220d999a2 Mon Sep 17 00:00:00 2001
From: Jurjan-Paul Medema <jurjanpaul@cq2.nl>
Date: Wed, 10 Oct 2012 17:13:35 +0200
Subject: [PATCH 10/11] HM/JPM: fixed bin/convert_oai_v1_to_v2; started work on bin/convert_oai_v2_to_v3

---
 bin/convert_oai_v1_to_v2                           |    4 +-
 bin/convert_oai_v2_to_v3                           |   61 ++++++++++++++++++++
 test/_alltests.py                                  |    1 +
 test/convertoaiv1tov2test.py                       |    2 +-
 test/convertoaiv2tov3test.py                       |   60 +++++++++++++++++++
 test/data/oai_conversion_v2_to_v3/oai.version      |    1 +
 .../prefixes/anotherPrefix.list                    |  Bin 0 -> 80 bytes
 .../prefixes/somePrefix.list                       |  Bin 0 -> 7976 bytes
 .../oai_conversion_v2_to_v3/sets/anotherSet.list   |  Bin 0 -> 40 bytes
 .../data/oai_conversion_v2_to_v3/sets/someSet.list |  Bin 0 -> 7976 bytes
 test/data/oai_conversion_v2_to_v3/tombStones.list  |  Bin 0 -> 7976 bytes
 11 files changed, 127 insertions(+), 2 deletions(-)
 create mode 100755 bin/convert_oai_v2_to_v3
 create mode 100644 test/convertoaiv2tov3test.py
 create mode 100644 test/data/oai_conversion_v2_to_v3/oai.version
 create mode 100644 test/data/oai_conversion_v2_to_v3/prefixes/anotherPrefix.list
 create mode 100644 test/data/oai_conversion_v2_to_v3/prefixes/somePrefix.list
 create mode 100644 test/data/oai_conversion_v2_to_v3/sets/anotherSet.list
 create mode 100644 test/data/oai_conversion_v2_to_v3/sets/someSet.list
 create mode 100644 test/data/oai_conversion_v2_to_v3/tombStones.list

diff --git a/bin/convert_oai_v1_to_v2 b/bin/convert_oai_v1_to_v2
index d2ca6e2..99bafd1 100755
--- a/bin/convert_oai_v1_to_v2
+++ b/bin/convert_oai_v1_to_v2
@@ -67,8 +67,10 @@ def main():
         print 'Usage: %s [OAI directory]' % sys.argv[0]
         exit(1)
     directory = sys.argv[1]
+    versionFile = join(directory, 'oai.version')
+    assert not isfile(versionFile) or open(versionFile).read() == '1'
     convertDir(directory)
-    open(join(directory, 'oai.version'), 'w').write(OaiJazz.version)
+    open(versionFile, 'w').write('2')
     print "Finished converting %s to OAI data format v2." % directory
 
 if __name__ == '__main__':
diff --git a/bin/convert_oai_v2_to_v3 b/bin/convert_oai_v2_to_v3
new file mode 100755
index 0000000..d7add88
--- /dev/null
+++ b/bin/convert_oai_v2_to_v3
@@ -0,0 +1,61 @@
+#!/usr/bin/env python2.6
+# -*- coding: utf-8 -*-
+## begin license ##
+#
+#    Meresco Oai are components to build Oai repositories, based on Meresco
+#    Core and Meresco Components.
+#    Copyright (C) 2010 Seek You Too (CQ2) http://www.cq2.nl
+#    Copyright (C) 2010 Stichting Kennisnet http://www.kennisnet.nl
+#
+#    This file is part of Meresco Oai.
+#
+#    Meresco Oai is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Meresco Oai is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Meresco Oai; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+from os import system                             #DO_NOT_DISTRIBUTE
+from sys import path as sysPath                   #DO_NOT_DISTRIBUTE
+system('find .. -name "*.pyc" | xargs rm -f')     #DO_NOT_DISTRIBUTE
+                                                  #DO_NOT_DISTRIBUTE
+from glob import glob                             #DO_NOT_DISTRIBUTE
+for path in glob('../deps.d/*'):                  #DO_NOT_DISTRIBUTE
+    sysPath.insert(0, path)                       #DO_NOT_DISTRIBUTE
+sysPath.insert(0,'..')                            #DO_NOT_DISTRIBUTE
+
+import sys
+from os import listdir, remove, rename
+from os.path import join, isdir, isfile
+from meresco.components.facetindex import IntegerList
+from meresco.oai import OaiJazz
+
+def convert(path):
+   pass
+   # TODO
+
+
+def main():
+    if len(sys.argv) != 2:
+        print 'Usage: %s [OAI directory]' % sys.argv[0]
+        exit(1)
+    directory = sys.argv[1]
+    versionFile = join(directory, 'oai.version')
+    version = open(versionFile).read()
+    assert version == '2', repr(version) 
+    convert(directory)
+    open(versionFile, 'w').write('3')
+    print "Finished converting %s to OAI data format v3." % directory
+
+if __name__ == '__main__':
+    main()
diff --git a/test/_alltests.py b/test/_alltests.py
index d831a93..0c0c83b 100644
--- a/test/_alltests.py
+++ b/test/_alltests.py
@@ -47,6 +47,7 @@ sysPath.insert(0,'..')                            #DO_NOT_DISTRIBUTE
 import unittest
 
 from convertoaiv1tov2test import ConvertOaiV1ToV2Test
+from convertoaiv2tov3test import ConvertOaiV2ToV3Test
 from fields2oairecordtest import Fields2OaiRecordTest
 from oaiaddrecordtest import OaiAddRecordTest
 from oaiaddrecordwithdefaultstest import OaiAddRecordWithDefaultsTest
diff --git a/test/convertoaiv1tov2test.py b/test/convertoaiv1tov2test.py
index 192c61d..6cc1a8f 100644
--- a/test/convertoaiv1tov2test.py
+++ b/test/convertoaiv1tov2test.py
@@ -70,4 +70,4 @@ class ConvertOaiV1ToV2Test(SeecrTestCase):
         convertedAnotherPrefix = PersistentSortedIntegerList(join(datadir, 'prefixes', 'anotherPrefix.list'), use64bits=True)
         self.assertEquals(range(0, 10), list(convertedAnotherPrefix))
 
-        self.assertEquals(OaiJazz.version, open(join(datadir, 'oai.version')).read())
+        self.assertEquals('2', open(join(datadir, 'oai.version')).read())
diff --git a/test/convertoaiv2tov3test.py b/test/convertoaiv2tov3test.py
new file mode 100644
index 0000000..252d0c4
--- /dev/null
+++ b/test/convertoaiv2tov3test.py
@@ -0,0 +1,60 @@
+## begin license ##
+# 
+# "Meresco Oai" are components to build Oai repositories, based on
+# "Meresco Core" and "Meresco Components". 
+# 
+# Copyright (C) 2012 Stichting Bibliotheek.nl (BNL) http://www.bibliotheek.nl
+# Copyright (C) 2012 Seecr (Seek You Too B.V.) http://seecr.nl
+# 
+# This file is part of "Meresco Oai"
+# 
+# "Meresco Oai" is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# "Meresco Oai" is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with "Meresco Oai"; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+# 
+## end license ##
+
+from os import system
+from os.path import dirname, join, abspath, isdir, isfile
+from shutil import copytree
+from bsddb import btopen
+
+from seecr.test import SeecrTestCase
+from meresco.components import PersistentSortedIntegerList
+from meresco.components.facetindex import IntegerList
+from meresco.oai import OaiJazz
+
+mypath = dirname(abspath(__file__))
+binDir = join(dirname(mypath), 'bin')
+if not isdir(binDir):
+    binDir = '/usr/bin'
+
+class ConvertOaiV2ToV3Test(SeecrTestCase):
+    def testConversion(self):
+        datadir = join(self.tempdir, 'oai_conversion_v2_to_v3')
+        copytree(join(mypath, 'data', 'oai_conversion_v2_to_v3'), datadir)
+        system("%s %s" % (join(binDir, 'convert_oai_v2_to_v3'), datadir))
+
+        self.assertTrue(isfile(join(datadir, 'stamp2identifier.bd')))
+        stamp2identifier = btopen(join(datadir, 'stamp2identifier.bd'))
+        for stamp, identifier in stamp2identifier.items():
+            print identifier
+            assertEquals(stamp, stamp2identifier['id:' + identifier])
+
+        self.assertTrue(isfile(join(datadir, 'identifier2setSpecs.bd')))
+        identifier2setSpecs = btopen(join(datadir, 'identifier2setSpecs.bd')) 
+        for identifier, setSpecs in identifier2setSpecs.items():
+            print identifier, setSpecs
+
+        self.assertEquals('3', open(join(datadir, 'oai.version')).read())
+
diff --git a/test/data/oai_conversion_v2_to_v3/oai.version b/test/data/oai_conversion_v2_to_v3/oai.version
new file mode 100644
index 0000000..d8263ee
--- /dev/null
+++ b/test/data/oai_conversion_v2_to_v3/oai.version
@@ -0,0 +1 @@
+2
\ No newline at end of file
diff --git a/test/data/oai_conversion_v2_to_v3/prefixes/anotherPrefix.list b/test/data/oai_conversion_v2_to_v3/prefixes/anotherPrefix.list
new file mode 100644
index 0000000000000000000000000000000000000000..e3e978ff210f46e4735964314c959bd7039cae48
GIT binary patch
literal 80
hcmXZNw*dek2mmlFi2nbu1IdzzHaxw&ojxvKKYs;y04@Lk

literal 0
HcmV?d00001

diff --git a/test/data/oai_conversion_v2_to_v3/prefixes/somePrefix.list b/test/data/oai_conversion_v2_to_v3/prefixes/somePrefix.list
new file mode 100644
index 0000000000000000000000000000000000000000..735ddc6bf12c8ed41d53b8721ffb1914aac3c0c4
GIT binary patch
literal 7976
zcmXZd!vYuv07Svqwr$(CZQHhO+qP}nwr#78lO8&Inf-$oAi)0%$UqFtpbW;~48f2L
z#n24HunfoWjKGMD#K?@osEo$wjKP?U#n_C)xQxg6Ou&Rp#KcU(q)f)-Ou>{)#nep0
zv`okJ%)pGy#LUdXtjxyj%)y+@#oWxpyv)b^EWm;+#KJ7XqAbSZEWwg2#nLRpvMk5)
ztiXz_#LBF~s;tK9tihVB#oDaHx~#|gY`}(W#KvsGrfkOMY{8an#nx=Ywrt1t?7)uf
z#Ln!(uI$F{?7^Pw#op}0zU;^T9KeAb#K9cGp&Z8H9Kn$s#nBwYu^h+ooWO~k#L1k(
zshq~?oWYr##o3(0xtz!OT)>4~#Kl~~rCi44T)~xG#noKHwOq&b+`x_8#Le8ot=z`#
z+`*mP#ogS)z1+wBJivoI#KSzoqddmrJjqi$%`-g9b3D%ryvR$u%qzUgYrM`IyvbX<
z%{#oyd%VvFe8@+9%qM)xXMD~Ve92dQ%{P3@cYMze{K!xI%rE?h|MDxp@jHL;Cx7ub
z|L`vZ1pNO5WFQ7+5C&y124@I{WGIGa7=~pyhGzsuWF$sr6h>t<MrRDhWGu#J9L8ll
z#%BU1WFjVJ5+-FbCT9w!WGbd+8m47Bre_9bWF}^27G`BOW@irOWG?1r9_D2}=4SyG
zWFZ!25f)`J7H0{TWGR+r8J1-^mS+W4WF=N+6;@?6R%Z>?WG&Wa9oA(%)@K7YWFt0a
z6E<ZtHfIaAWGl928@6RTwr2-+WG8lJ7j|Vgc4rUvWH0t+ANFNG_U8Z&<RA{_5Dw)q
z4(AAt<S35j7>?yQj^_kU<Rnh!6i($dPUj5H<SfqS9M0uD&gTLy<RUKS5-#O3F6Roa
z<SMS_8m{F!uIC1B<R)(B7H;J>Zs!i}<Sy>!9`5Bn?&kp><RKpB5gz3+9_I<3<SCx!
z8J^`ip63N#<RxC_6<*~vUgr(o<SpLj9p2?V-sb~8<Rd=j6F%iLKIaR*<SV}B8@}Z`
zzUK#i<R^aS7yiS4`IX=Joj>@KzxbPf_?H0!=|2N8FoQ5CgE2TmFeF1UG{Z0~!!bM~
zFd`!{GNUjmqcJ*TFeYO$HsdfZ<1s!HFd-8$F_SPUlQB6{FeOtlHPbLH(=k0WFe5WD
zGqW%&voSk!Feh^{H}fzr^D#dQupkSuFpID#i?KLMup~>dG|R9o%dtEwup%q5GOMsE
ztFbz3vKDKz4(qZW>$3qHvJo4z37fJRo3jO5vK3pi4coFE+p_~ZvJ*SA3%jx#yR!#-
zvKM=^5Bsto`*Q#Xau5e|2#0bQhjRo+aui2%499XD$8!QFauO$V3a4@!r*j5pau#QE
z4(D<n=W_uUauFAE372vimvaSIauru|4cBrV*K-3mauYXm3%7C`w{r(~au;`V5BG8(
z_wxV`@(>U62#@j@kMjgi@)S?=4A1f$&+`H=@)9re3a|1Suk!|P@)mFN4)5|F@ACm4
z@(~~N37_&ApYsJ@@)ck64d3z|-}3`M@)JMv3;*H2{K{|q&L8~AU;NEK{L27=b)SJ4
zm_Znn!5Ew&7?PnFnqe50;TWC~7?F_}nNb*((HNaE7?ZIWn{gPI@fe>8n2?E>m`RwF
z$(Woen3AcOnrWDp>6o4wn30*7nOT^X*_fR<n3K7fn|YX*`Iw&tSdfKSm_=BW#aNsr
zSdyh!nq^p)<yf8-Sdo=jnN?Vo)mWW1Sd+C_n{`;1^;n+`*pQ9bm`&J}&DfkR*pjW-
znr+yY?bx0j*pZ#snO)eG-PoNy*pt23n|;`q{n(!aIFN%lm_s;}!#JEHIFh3{nqxSY
z<2arZIFXY$nNv8G(>R?oIFqwDn{zmq^EjUixR8sum`k{n%eb5?xRR^5nrpb0>$sj9
zxRIN<nOnG(+qj)OxRblMn|rvI`?#M6c#wy9m`8Y&$9SA4c#@}hnrC>H=XjnMc#)TQ
knOAs~*La;bc$2qyn|FAZ_jsQV_>hnIm{0hW&-k4G0Y>@j&Hw-a

literal 0
HcmV?d00001

diff --git a/test/data/oai_conversion_v2_to_v3/sets/anotherSet.list b/test/data/oai_conversion_v2_to_v3/sets/anotherSet.list
new file mode 100644
index 0000000000000000000000000000000000000000..06d89cdd78da52dc097390d1397fcf88bd608e05
GIT binary patch
literal 40
VcmZQ&fB-fq%?_nGpfo3x1^@#f03-ka

literal 0
HcmV?d00001

diff --git a/test/data/oai_conversion_v2_to_v3/sets/someSet.list b/test/data/oai_conversion_v2_to_v3/sets/someSet.list
new file mode 100644
index 0000000000000000000000000000000000000000..735ddc6bf12c8ed41d53b8721ffb1914aac3c0c4
GIT binary patch
literal 7976
zcmXZd!vYuv07Svqwr$(CZQHhO+qP}nwr#78lO8&Inf-$oAi)0%$UqFtpbW;~48f2L
z#n24HunfoWjKGMD#K?@osEo$wjKP?U#n_C)xQxg6Ou&Rp#KcU(q)f)-Ou>{)#nep0
zv`okJ%)pGy#LUdXtjxyj%)y+@#oWxpyv)b^EWm;+#KJ7XqAbSZEWwg2#nLRpvMk5)
ztiXz_#LBF~s;tK9tihVB#oDaHx~#|gY`}(W#KvsGrfkOMY{8an#nx=Ywrt1t?7)uf
z#Ln!(uI$F{?7^Pw#op}0zU;^T9KeAb#K9cGp&Z8H9Kn$s#nBwYu^h+ooWO~k#L1k(
zshq~?oWYr##o3(0xtz!OT)>4~#Kl~~rCi44T)~xG#noKHwOq&b+`x_8#Le8ot=z`#
z+`*mP#ogS)z1+wBJivoI#KSzoqddmrJjqi$%`-g9b3D%ryvR$u%qzUgYrM`IyvbX<
z%{#oyd%VvFe8@+9%qM)xXMD~Ve92dQ%{P3@cYMze{K!xI%rE?h|MDxp@jHL;Cx7ub
z|L`vZ1pNO5WFQ7+5C&y124@I{WGIGa7=~pyhGzsuWF$sr6h>t<MrRDhWGu#J9L8ll
z#%BU1WFjVJ5+-FbCT9w!WGbd+8m47Bre_9bWF}^27G`BOW@irOWG?1r9_D2}=4SyG
zWFZ!25f)`J7H0{TWGR+r8J1-^mS+W4WF=N+6;@?6R%Z>?WG&Wa9oA(%)@K7YWFt0a
z6E<ZtHfIaAWGl928@6RTwr2-+WG8lJ7j|Vgc4rUvWH0t+ANFNG_U8Z&<RA{_5Dw)q
z4(AAt<S35j7>?yQj^_kU<Rnh!6i($dPUj5H<SfqS9M0uD&gTLy<RUKS5-#O3F6Roa
z<SMS_8m{F!uIC1B<R)(B7H;J>Zs!i}<Sy>!9`5Bn?&kp><RKpB5gz3+9_I<3<SCx!
z8J^`ip63N#<RxC_6<*~vUgr(o<SpLj9p2?V-sb~8<Rd=j6F%iLKIaR*<SV}B8@}Z`
zzUK#i<R^aS7yiS4`IX=Joj>@KzxbPf_?H0!=|2N8FoQ5CgE2TmFeF1UG{Z0~!!bM~
zFd`!{GNUjmqcJ*TFeYO$HsdfZ<1s!HFd-8$F_SPUlQB6{FeOtlHPbLH(=k0WFe5WD
zGqW%&voSk!Feh^{H}fzr^D#dQupkSuFpID#i?KLMup~>dG|R9o%dtEwup%q5GOMsE
ztFbz3vKDKz4(qZW>$3qHvJo4z37fJRo3jO5vK3pi4coFE+p_~ZvJ*SA3%jx#yR!#-
zvKM=^5Bsto`*Q#Xau5e|2#0bQhjRo+aui2%499XD$8!QFauO$V3a4@!r*j5pau#QE
z4(D<n=W_uUauFAE372vimvaSIauru|4cBrV*K-3mauYXm3%7C`w{r(~au;`V5BG8(
z_wxV`@(>U62#@j@kMjgi@)S?=4A1f$&+`H=@)9re3a|1Suk!|P@)mFN4)5|F@ACm4
z@(~~N37_&ApYsJ@@)ck64d3z|-}3`M@)JMv3;*H2{K{|q&L8~AU;NEK{L27=b)SJ4
zm_Znn!5Ew&7?PnFnqe50;TWC~7?F_}nNb*((HNaE7?ZIWn{gPI@fe>8n2?E>m`RwF
z$(Woen3AcOnrWDp>6o4wn30*7nOT^X*_fR<n3K7fn|YX*`Iw&tSdfKSm_=BW#aNsr
zSdyh!nq^p)<yf8-Sdo=jnN?Vo)mWW1Sd+C_n{`;1^;n+`*pQ9bm`&J}&DfkR*pjW-
znr+yY?bx0j*pZ#snO)eG-PoNy*pt23n|;`q{n(!aIFN%lm_s;}!#JEHIFh3{nqxSY
z<2arZIFXY$nNv8G(>R?oIFqwDn{zmq^EjUixR8sum`k{n%eb5?xRR^5nrpb0>$sj9
zxRIN<nOnG(+qj)OxRblMn|rvI`?#M6c#wy9m`8Y&$9SA4c#@}hnrC>H=XjnMc#)TQ
knOAs~*La;bc$2qyn|FAZ_jsQV_>hnIm{0hW&-k4G0Y>@j&Hw-a

literal 0
HcmV?d00001

diff --git a/test/data/oai_conversion_v2_to_v3/tombStones.list b/test/data/oai_conversion_v2_to_v3/tombStones.list
new file mode 100644
index 0000000000000000000000000000000000000000..735ddc6bf12c8ed41d53b8721ffb1914aac3c0c4
GIT binary patch
literal 7976
zcmXZd!vYuv07Svqwr$(CZQHhO+qP}nwr#78lO8&Inf-$oAi)0%$UqFtpbW;~48f2L
z#n24HunfoWjKGMD#K?@osEo$wjKP?U#n_C)xQxg6Ou&Rp#KcU(q)f)-Ou>{)#nep0
zv`okJ%)pGy#LUdXtjxyj%)y+@#oWxpyv)b^EWm;+#KJ7XqAbSZEWwg2#nLRpvMk5)
ztiXz_#LBF~s;tK9tihVB#oDaHx~#|gY`}(W#KvsGrfkOMY{8an#nx=Ywrt1t?7)uf
z#Ln!(uI$F{?7^Pw#op}0zU;^T9KeAb#K9cGp&Z8H9Kn$s#nBwYu^h+ooWO~k#L1k(
zshq~?oWYr##o3(0xtz!OT)>4~#Kl~~rCi44T)~xG#noKHwOq&b+`x_8#Le8ot=z`#
z+`*mP#ogS)z1+wBJivoI#KSzoqddmrJjqi$%`-g9b3D%ryvR$u%qzUgYrM`IyvbX<
z%{#oyd%VvFe8@+9%qM)xXMD~Ve92dQ%{P3@cYMze{K!xI%rE?h|MDxp@jHL;Cx7ub
z|L`vZ1pNO5WFQ7+5C&y124@I{WGIGa7=~pyhGzsuWF$sr6h>t<MrRDhWGu#J9L8ll
z#%BU1WFjVJ5+-FbCT9w!WGbd+8m47Bre_9bWF}^27G`BOW@irOWG?1r9_D2}=4SyG
zWFZ!25f)`J7H0{TWGR+r8J1-^mS+W4WF=N+6;@?6R%Z>?WG&Wa9oA(%)@K7YWFt0a
z6E<ZtHfIaAWGl928@6RTwr2-+WG8lJ7j|Vgc4rUvWH0t+ANFNG_U8Z&<RA{_5Dw)q
z4(AAt<S35j7>?yQj^_kU<Rnh!6i($dPUj5H<SfqS9M0uD&gTLy<RUKS5-#O3F6Roa
z<SMS_8m{F!uIC1B<R)(B7H;J>Zs!i}<Sy>!9`5Bn?&kp><RKpB5gz3+9_I<3<SCx!
z8J^`ip63N#<RxC_6<*~vUgr(o<SpLj9p2?V-sb~8<Rd=j6F%iLKIaR*<SV}B8@}Z`
zzUK#i<R^aS7yiS4`IX=Joj>@KzxbPf_?H0!=|2N8FoQ5CgE2TmFeF1UG{Z0~!!bM~
zFd`!{GNUjmqcJ*TFeYO$HsdfZ<1s!HFd-8$F_SPUlQB6{FeOtlHPbLH(=k0WFe5WD
zGqW%&voSk!Feh^{H}fzr^D#dQupkSuFpID#i?KLMup~>dG|R9o%dtEwup%q5GOMsE
ztFbz3vKDKz4(qZW>$3qHvJo4z37fJRo3jO5vK3pi4coFE+p_~ZvJ*SA3%jx#yR!#-
zvKM=^5Bsto`*Q#Xau5e|2#0bQhjRo+aui2%499XD$8!QFauO$V3a4@!r*j5pau#QE
z4(D<n=W_uUauFAE372vimvaSIauru|4cBrV*K-3mauYXm3%7C`w{r(~au;`V5BG8(
z_wxV`@(>U62#@j@kMjgi@)S?=4A1f$&+`H=@)9re3a|1Suk!|P@)mFN4)5|F@ACm4
z@(~~N37_&ApYsJ@@)ck64d3z|-}3`M@)JMv3;*H2{K{|q&L8~AU;NEK{L27=b)SJ4
zm_Znn!5Ew&7?PnFnqe50;TWC~7?F_}nNb*((HNaE7?ZIWn{gPI@fe>8n2?E>m`RwF
z$(Woen3AcOnrWDp>6o4wn30*7nOT^X*_fR<n3K7fn|YX*`Iw&tSdfKSm_=BW#aNsr
zSdyh!nq^p)<yf8-Sdo=jnN?Vo)mWW1Sd+C_n{`;1^;n+`*pQ9bm`&J}&DfkR*pjW-
znr+yY?bx0j*pZ#snO)eG-PoNy*pt23n|;`q{n(!aIFN%lm_s;}!#JEHIFh3{nqxSY
z<2arZIFXY$nNv8G(>R?oIFqwDn{zmq^EjUixR8sum`k{n%eb5?xRR^5nrpb0>$sj9
zxRIN<nOnG(+qj)OxRblMn|rvI`?#M6c#wy9m`8Y&$9SA4c#@}hnrC>H=XjnMc#)TQ
knOAs~*La;bc$2qyn|FAZ_jsQV_>hnIm{0hW&-k4G0Y>@j&Hw-a

literal 0
HcmV?d00001

-- 
1.7.2.5


From 2198143538ae0396e19ffb57fe8ba348287e2a27 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Hendrik=20Mor=C3=A9e?= <hendrik@seecr.nl>
Date: Thu, 11 Oct 2012 09:49:31 +0200
Subject: [PATCH 11/11] HM/JPM: finished convert_oai_v2_to_v3

---
 bin/convert_oai_v2_to_v3                           |   17 +++++++++++++-
 test/convertoaiv2tov3test.py                       |   23 +++++++++++++++----
 .../identifier2setSpecs/keyvalue                   |  Bin 0 -> 8192 bytes
 .../prefixes/anotherPrefix.list                    |  Bin 80 -> 0 bytes
 .../data/oai_conversion_v2_to_v3/prefixes/rdf.list |  Bin 0 -> 24 bytes
 .../prefixes/rdf.list.deleted                      |  Bin 0 -> 8 bytes
 .../prefixes/somePrefix.list                       |  Bin 7976 -> 0 bytes
 .../prefixesInfo/rdf.namespace                     |    1 +
 .../oai_conversion_v2_to_v3/sets/anotherSet.list   |  Bin 40 -> 0 bytes
 .../data/oai_conversion_v2_to_v3/sets/someSet.list |  Bin 7976 -> 0 bytes
 .../sets/testCollection.list                       |  Bin 0 -> 24 bytes
 .../sets/testCollection.list.deleted               |  Bin 0 -> 8 bytes
 .../stamp2identifier/keyvalue                      |  Bin 0 -> 8192 bytes
 .../stamp2identifier/valuekey                      |  Bin 0 -> 8192 bytes
 test/data/oai_conversion_v2_to_v3/tombStones.list  |  Bin 7976 -> 8 bytes
 15 files changed, 34 insertions(+), 7 deletions(-)
 create mode 100644 test/data/oai_conversion_v2_to_v3/identifier2setSpecs/keyvalue
 delete mode 100644 test/data/oai_conversion_v2_to_v3/prefixes/anotherPrefix.list
 create mode 100644 test/data/oai_conversion_v2_to_v3/prefixes/rdf.list
 create mode 100644 test/data/oai_conversion_v2_to_v3/prefixes/rdf.list.deleted
 delete mode 100644 test/data/oai_conversion_v2_to_v3/prefixes/somePrefix.list
 create mode 100644 test/data/oai_conversion_v2_to_v3/prefixesInfo/rdf.namespace
 create mode 100644 test/data/oai_conversion_v2_to_v3/prefixesInfo/rdf.schema
 delete mode 100644 test/data/oai_conversion_v2_to_v3/sets/anotherSet.list
 delete mode 100644 test/data/oai_conversion_v2_to_v3/sets/someSet.list
 create mode 100644 test/data/oai_conversion_v2_to_v3/sets/testCollection.list
 create mode 100644 test/data/oai_conversion_v2_to_v3/sets/testCollection.list.deleted
 create mode 100644 test/data/oai_conversion_v2_to_v3/stamp2identifier/keyvalue
 create mode 100644 test/data/oai_conversion_v2_to_v3/stamp2identifier/valuekey

diff --git a/bin/convert_oai_v2_to_v3 b/bin/convert_oai_v2_to_v3
index d7add88..19bcd7d 100755
--- a/bin/convert_oai_v2_to_v3
+++ b/bin/convert_oai_v2_to_v3
@@ -37,13 +37,25 @@ sysPath.insert(0,'..')                            #DO_NOT_DISTRIBUTE
 import sys
 from os import listdir, remove, rename
 from os.path import join, isdir, isfile
+from shutil import rmtree
+from bsddb import btopen
 from meresco.components.facetindex import IntegerList
 from meresco.oai import OaiJazz
 
+
 def convert(path):
-   pass
-   # TODO
+    stamp2identifier = btopen(join(path, "stamp2identifier.bd"))
+    orig_stamp2identifier = btopen(join(path, "stamp2identifier", "keyvalue"), 'r')
+    orig_identifier2stamp = btopen(join(path, "stamp2identifier", "valuekey"), 'r')
+    for stamp, identifier in orig_stamp2identifier.items():
+        stamp2identifier[stamp] = identifier
+        stamp2identifier["id:"+identifier] = stamp
+    stamp2identifier.sync()
+    stamp2identifier.close()
+    rmtree(join(path, 'stamp2identifier'))
 
+    rename(join(path, 'identifier2setSpecs', 'keyvalue'), join(path, 'identifier2setSpecs.bd'))
+    rmtree(join(path, 'identifier2setSpecs'))
 
 def main():
     if len(sys.argv) != 2:
@@ -59,3 +71,4 @@ def main():
 
 if __name__ == '__main__':
     main()
+
diff --git a/test/convertoaiv2tov3test.py b/test/convertoaiv2tov3test.py
index 252d0c4..3bc0a73 100644
--- a/test/convertoaiv2tov3test.py
+++ b/test/convertoaiv2tov3test.py
@@ -47,14 +47,27 @@ class ConvertOaiV2ToV3Test(SeecrTestCase):
 
         self.assertTrue(isfile(join(datadir, 'stamp2identifier.bd')))
         stamp2identifier = btopen(join(datadir, 'stamp2identifier.bd'))
-        for stamp, identifier in stamp2identifier.items():
-            print identifier
-            assertEquals(stamp, stamp2identifier['id:' + identifier])
+        self.assertEquals(4, len(stamp2identifier))
+        for key, value in stamp2identifier.items():
+            if key.startswith('id:'):
+                stamp, identifier = value, key[len('id:'):]
+                self.assertEquals(identifier, stamp2identifier[stamp])
+            else:
+                stamp, identifier = key, value
+                self.assertEquals(stamp, stamp2identifier["id:" + identifier])
+        self.assertFalse(isdir(join(datadir, 'stamp2identifier')))
 
         self.assertTrue(isfile(join(datadir, 'identifier2setSpecs.bd')))
         identifier2setSpecs = btopen(join(datadir, 'identifier2setSpecs.bd')) 
-        for identifier, setSpecs in identifier2setSpecs.items():
-            print identifier, setSpecs
+        self.assertEquals(2, len(identifier2setSpecs))
+        self.assertFalse(isdir(join(datadir, 'identifier2setSpecs')))
+
+        self.assertTrue(isfile(join(datadir, 'tombStones.list')))
+        self.assertTrue(isfile(join(datadir, 'prefixes', 'rdf.list')))
+        self.assertTrue(isfile(join(datadir, 'prefixesInfo', 'rdf.schema')))
+        self.assertTrue(isfile(join(datadir, 'prefixesInfo', 'rdf.namespace')))
+        self.assertTrue(isfile(join(datadir, 'sets', 'testCollection.list')))
 
         self.assertEquals('3', open(join(datadir, 'oai.version')).read())
 
+
diff --git a/test/data/oai_conversion_v2_to_v3/identifier2setSpecs/keyvalue b/test/data/oai_conversion_v2_to_v3/identifier2setSpecs/keyvalue
new file mode 100644
index 0000000000000000000000000000000000000000..0928ccad1f2b63e66ae1fbf35d2e5b5360e76c22
GIT binary patch
literal 8192
zcmeI#F>b;z6b9gD+6*i;l{i38fXRR$-l_~7qC*79Q;K9r)K~(c&Yg0DE}WuMkHN+T
zdJJqtC=v{8EWaho&(C^K*0(((BH^}Q(=ed64?1oig8w(4ZkCL8!Lz&ke!u;EeLgg4
zY8|5&cQ!pwj|d<D0SG_<0uX=z1Rwwb2tWV=5V)&=pViOj^+&3u2>#?&Ze%SlzlQn$
z(gYa@KmY;|fB*y_009U<00Izzz^wvLBrI1pE{x&S&WeRAR3zT5EwxhXvR5&uAH9W9
tyqe5Q!)iG*CYf@Qv0=+uQWd`FTAwb7JWus_9P8Iuhl5c#8V>sr?E%TQF)aW9

literal 0
HcmV?d00001

diff --git a/test/data/oai_conversion_v2_to_v3/prefixes/anotherPrefix.list b/test/data/oai_conversion_v2_to_v3/prefixes/anotherPrefix.list
deleted file mode 100644
index e3e978ff210f46e4735964314c959bd7039cae48..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 80
hcmXZNw*dek2mmlFi2nbu1IdzzHaxw&ojxvKKYs;y04@Lk

diff --git a/test/data/oai_conversion_v2_to_v3/prefixes/rdf.list b/test/data/oai_conversion_v2_to_v3/prefixes/rdf.list
new file mode 100644
index 0000000000000000000000000000000000000000..7f40deb970c066112eb9c622b668e407655b9846
GIT binary patch
literal 24
YcmbPnd#U{4(<}_89?QY>;UEYN0EguY3;+NC

literal 0
HcmV?d00001

diff --git a/test/data/oai_conversion_v2_to_v3/prefixes/rdf.list.deleted b/test/data/oai_conversion_v2_to_v3/prefixes/rdf.list.deleted
new file mode 100644
index 0000000000000000000000000000000000000000..20d5cb86e6dff1f3684dc229a358a2ea697cecfb
GIT binary patch
literal 8
KcmZQ%fB*mh5C8%I

literal 0
HcmV?d00001

diff --git a/test/data/oai_conversion_v2_to_v3/prefixes/somePrefix.list b/test/data/oai_conversion_v2_to_v3/prefixes/somePrefix.list
deleted file mode 100644
index 735ddc6bf12c8ed41d53b8721ffb1914aac3c0c4..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 7976
zcmXZd!vYuv07Svqwr$(CZQHhO+qP}nwr#78lO8&Inf-$oAi)0%$UqFtpbW;~48f2L
z#n24HunfoWjKGMD#K?@osEo$wjKP?U#n_C)xQxg6Ou&Rp#KcU(q)f)-Ou>{)#nep0
zv`okJ%)pGy#LUdXtjxyj%)y+@#oWxpyv)b^EWm;+#KJ7XqAbSZEWwg2#nLRpvMk5)
ztiXz_#LBF~s;tK9tihVB#oDaHx~#|gY`}(W#KvsGrfkOMY{8an#nx=Ywrt1t?7)uf
z#Ln!(uI$F{?7^Pw#op}0zU;^T9KeAb#K9cGp&Z8H9Kn$s#nBwYu^h+ooWO~k#L1k(
zshq~?oWYr##o3(0xtz!OT)>4~#Kl~~rCi44T)~xG#noKHwOq&b+`x_8#Le8ot=z`#
z+`*mP#ogS)z1+wBJivoI#KSzoqddmrJjqi$%`-g9b3D%ryvR$u%qzUgYrM`IyvbX<
z%{#oyd%VvFe8@+9%qM)xXMD~Ve92dQ%{P3@cYMze{K!xI%rE?h|MDxp@jHL;Cx7ub
z|L`vZ1pNO5WFQ7+5C&y124@I{WGIGa7=~pyhGzsuWF$sr6h>t<MrRDhWGu#J9L8ll
z#%BU1WFjVJ5+-FbCT9w!WGbd+8m47Bre_9bWF}^27G`BOW@irOWG?1r9_D2}=4SyG
zWFZ!25f)`J7H0{TWGR+r8J1-^mS+W4WF=N+6;@?6R%Z>?WG&Wa9oA(%)@K7YWFt0a
z6E<ZtHfIaAWGl928@6RTwr2-+WG8lJ7j|Vgc4rUvWH0t+ANFNG_U8Z&<RA{_5Dw)q
z4(AAt<S35j7>?yQj^_kU<Rnh!6i($dPUj5H<SfqS9M0uD&gTLy<RUKS5-#O3F6Roa
z<SMS_8m{F!uIC1B<R)(B7H;J>Zs!i}<Sy>!9`5Bn?&kp><RKpB5gz3+9_I<3<SCx!
z8J^`ip63N#<RxC_6<*~vUgr(o<SpLj9p2?V-sb~8<Rd=j6F%iLKIaR*<SV}B8@}Z`
zzUK#i<R^aS7yiS4`IX=Joj>@KzxbPf_?H0!=|2N8FoQ5CgE2TmFeF1UG{Z0~!!bM~
zFd`!{GNUjmqcJ*TFeYO$HsdfZ<1s!HFd-8$F_SPUlQB6{FeOtlHPbLH(=k0WFe5WD
zGqW%&voSk!Feh^{H}fzr^D#dQupkSuFpID#i?KLMup~>dG|R9o%dtEwup%q5GOMsE
ztFbz3vKDKz4(qZW>$3qHvJo4z37fJRo3jO5vK3pi4coFE+p_~ZvJ*SA3%jx#yR!#-
zvKM=^5Bsto`*Q#Xau5e|2#0bQhjRo+aui2%499XD$8!QFauO$V3a4@!r*j5pau#QE
z4(D<n=W_uUauFAE372vimvaSIauru|4cBrV*K-3mauYXm3%7C`w{r(~au;`V5BG8(
z_wxV`@(>U62#@j@kMjgi@)S?=4A1f$&+`H=@)9re3a|1Suk!|P@)mFN4)5|F@ACm4
z@(~~N37_&ApYsJ@@)ck64d3z|-}3`M@)JMv3;*H2{K{|q&L8~AU;NEK{L27=b)SJ4
zm_Znn!5Ew&7?PnFnqe50;TWC~7?F_}nNb*((HNaE7?ZIWn{gPI@fe>8n2?E>m`RwF
z$(Woen3AcOnrWDp>6o4wn30*7nOT^X*_fR<n3K7fn|YX*`Iw&tSdfKSm_=BW#aNsr
zSdyh!nq^p)<yf8-Sdo=jnN?Vo)mWW1Sd+C_n{`;1^;n+`*pQ9bm`&J}&DfkR*pjW-
znr+yY?bx0j*pZ#snO)eG-PoNy*pt23n|;`q{n(!aIFN%lm_s;}!#JEHIFh3{nqxSY
z<2arZIFXY$nNv8G(>R?oIFqwDn{zmq^EjUixR8sum`k{n%eb5?xRR^5nrpb0>$sj9
zxRIN<nOnG(+qj)OxRblMn|rvI`?#M6c#wy9m`8Y&$9SA4c#@}hnrC>H=XjnMc#)TQ
knOAs~*La;bc$2qyn|FAZ_jsQV_>hnIm{0hW&-k4G0Y>@j&Hw-a

diff --git a/test/data/oai_conversion_v2_to_v3/prefixesInfo/rdf.namespace b/test/data/oai_conversion_v2_to_v3/prefixesInfo/rdf.namespace
new file mode 100644
index 0000000..42689ae
--- /dev/null
+++ b/test/data/oai_conversion_v2_to_v3/prefixesInfo/rdf.namespace
@@ -0,0 +1 @@
+http://www.w3.org/1999/02/22-rdf-syntax-ns#
\ No newline at end of file
diff --git a/test/data/oai_conversion_v2_to_v3/prefixesInfo/rdf.schema b/test/data/oai_conversion_v2_to_v3/prefixesInfo/rdf.schema
new file mode 100644
index 0000000..e69de29
diff --git a/test/data/oai_conversion_v2_to_v3/sets/anotherSet.list b/test/data/oai_conversion_v2_to_v3/sets/anotherSet.list
deleted file mode 100644
index 06d89cdd78da52dc097390d1397fcf88bd608e05..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 40
VcmZQ&fB-fq%?_nGpfo3x1^@#f03-ka

diff --git a/test/data/oai_conversion_v2_to_v3/sets/someSet.list b/test/data/oai_conversion_v2_to_v3/sets/someSet.list
deleted file mode 100644
index 735ddc6bf12c8ed41d53b8721ffb1914aac3c0c4..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 7976
zcmXZd!vYuv07Svqwr$(CZQHhO+qP}nwr#78lO8&Inf-$oAi)0%$UqFtpbW;~48f2L
z#n24HunfoWjKGMD#K?@osEo$wjKP?U#n_C)xQxg6Ou&Rp#KcU(q)f)-Ou>{)#nep0
zv`okJ%)pGy#LUdXtjxyj%)y+@#oWxpyv)b^EWm;+#KJ7XqAbSZEWwg2#nLRpvMk5)
ztiXz_#LBF~s;tK9tihVB#oDaHx~#|gY`}(W#KvsGrfkOMY{8an#nx=Ywrt1t?7)uf
z#Ln!(uI$F{?7^Pw#op}0zU;^T9KeAb#K9cGp&Z8H9Kn$s#nBwYu^h+ooWO~k#L1k(
zshq~?oWYr##o3(0xtz!OT)>4~#Kl~~rCi44T)~xG#noKHwOq&b+`x_8#Le8ot=z`#
z+`*mP#ogS)z1+wBJivoI#KSzoqddmrJjqi$%`-g9b3D%ryvR$u%qzUgYrM`IyvbX<
z%{#oyd%VvFe8@+9%qM)xXMD~Ve92dQ%{P3@cYMze{K!xI%rE?h|MDxp@jHL;Cx7ub
z|L`vZ1pNO5WFQ7+5C&y124@I{WGIGa7=~pyhGzsuWF$sr6h>t<MrRDhWGu#J9L8ll
z#%BU1WFjVJ5+-FbCT9w!WGbd+8m47Bre_9bWF}^27G`BOW@irOWG?1r9_D2}=4SyG
zWFZ!25f)`J7H0{TWGR+r8J1-^mS+W4WF=N+6;@?6R%Z>?WG&Wa9oA(%)@K7YWFt0a
z6E<ZtHfIaAWGl928@6RTwr2-+WG8lJ7j|Vgc4rUvWH0t+ANFNG_U8Z&<RA{_5Dw)q
z4(AAt<S35j7>?yQj^_kU<Rnh!6i($dPUj5H<SfqS9M0uD&gTLy<RUKS5-#O3F6Roa
z<SMS_8m{F!uIC1B<R)(B7H;J>Zs!i}<Sy>!9`5Bn?&kp><RKpB5gz3+9_I<3<SCx!
z8J^`ip63N#<RxC_6<*~vUgr(o<SpLj9p2?V-sb~8<Rd=j6F%iLKIaR*<SV}B8@}Z`
zzUK#i<R^aS7yiS4`IX=Joj>@KzxbPf_?H0!=|2N8FoQ5CgE2TmFeF1UG{Z0~!!bM~
zFd`!{GNUjmqcJ*TFeYO$HsdfZ<1s!HFd-8$F_SPUlQB6{FeOtlHPbLH(=k0WFe5WD
zGqW%&voSk!Feh^{H}fzr^D#dQupkSuFpID#i?KLMup~>dG|R9o%dtEwup%q5GOMsE
ztFbz3vKDKz4(qZW>$3qHvJo4z37fJRo3jO5vK3pi4coFE+p_~ZvJ*SA3%jx#yR!#-
zvKM=^5Bsto`*Q#Xau5e|2#0bQhjRo+aui2%499XD$8!QFauO$V3a4@!r*j5pau#QE
z4(D<n=W_uUauFAE372vimvaSIauru|4cBrV*K-3mauYXm3%7C`w{r(~au;`V5BG8(
z_wxV`@(>U62#@j@kMjgi@)S?=4A1f$&+`H=@)9re3a|1Suk!|P@)mFN4)5|F@ACm4
z@(~~N37_&ApYsJ@@)ck64d3z|-}3`M@)JMv3;*H2{K{|q&L8~AU;NEK{L27=b)SJ4
zm_Znn!5Ew&7?PnFnqe50;TWC~7?F_}nNb*((HNaE7?ZIWn{gPI@fe>8n2?E>m`RwF
z$(Woen3AcOnrWDp>6o4wn30*7nOT^X*_fR<n3K7fn|YX*`Iw&tSdfKSm_=BW#aNsr
zSdyh!nq^p)<yf8-Sdo=jnN?Vo)mWW1Sd+C_n{`;1^;n+`*pQ9bm`&J}&DfkR*pjW-
znr+yY?bx0j*pZ#snO)eG-PoNy*pt23n|;`q{n(!aIFN%lm_s;}!#JEHIFh3{nqxSY
z<2arZIFXY$nNv8G(>R?oIFqwDn{zmq^EjUixR8sum`k{n%eb5?xRR^5nrpb0>$sj9
zxRIN<nOnG(+qj)OxRblMn|rvI`?#M6c#wy9m`8Y&$9SA4c#@}hnrC>H=XjnMc#)TQ
knOAs~*La;bc$2qyn|FAZ_jsQV_>hnIm{0hW&-k4G0Y>@j&Hw-a

diff --git a/test/data/oai_conversion_v2_to_v3/sets/testCollection.list b/test/data/oai_conversion_v2_to_v3/sets/testCollection.list
new file mode 100644
index 0000000000000000000000000000000000000000..7f40deb970c066112eb9c622b668e407655b9846
GIT binary patch
literal 24
YcmbPnd#U{4(<}_89?QY>;UEYN0EguY3;+NC

literal 0
HcmV?d00001

diff --git a/test/data/oai_conversion_v2_to_v3/sets/testCollection.list.deleted b/test/data/oai_conversion_v2_to_v3/sets/testCollection.list.deleted
new file mode 100644
index 0000000000000000000000000000000000000000..20d5cb86e6dff1f3684dc229a358a2ea697cecfb
GIT binary patch
literal 8
KcmZQ%fB*mh5C8%I

literal 0
HcmV?d00001

diff --git a/test/data/oai_conversion_v2_to_v3/stamp2identifier/keyvalue b/test/data/oai_conversion_v2_to_v3/stamp2identifier/keyvalue
new file mode 100644
index 0000000000000000000000000000000000000000..60e65131299c079ae40db49fb12eff1823922939
GIT binary patch
literal 8192
zcmeI%L5jjK6b9fIu?rUxh1u%~jA@-V=}rVaMzI=H$k?I<2hZT4JcK*(27+6cro$8k
zH?y0~A9&>DC4}(p9w8!PF3OQgj~Zpta`BTq_sViLn)>Xu-J)~3-^N*0C93_VT{l;E
zK6jBp00Izz00bZa0SG_<0uX=z1R(IA0%foM+OOB?z?paDCw}Ay{{Axb|L-QKKmY;|
zfB*y_009U<00Izz00jOjAc!rCB9DdG=e?~lvrTVph54R-<<^MZ%Gx9~$=p~|n0d0z
xvh{A&A|``@)`3zo)M4O<5q%I_EN1a!GKz<zSbi$0qNuOkxBkmn6-K^4pa)8nEtLQO

literal 0
HcmV?d00001

diff --git a/test/data/oai_conversion_v2_to_v3/stamp2identifier/valuekey b/test/data/oai_conversion_v2_to_v3/stamp2identifier/valuekey
new file mode 100644
index 0000000000000000000000000000000000000000..dd50cb3767b2e9a8bc664b767939200add67e0f5
GIT binary patch
literal 8192
zcmeI%J&FP`6bJAZaS9uw-~l{=F*7=oOt)Bgj6uhsLexPA6wlxdY&?pUC)mzj_5$0R
z5k<kq&gLHod3pID{JKYoh?wg|8%mEVMNo777ChIA^rKbv*{i$BaeqEt{vW4_O7{&-
zH$JoXBnAjT00Izz00bZa0SG_<0uX=z1imUz)atMGdYN{dd4K$uANY>HKMnQ&y9qK7
zfB*y_009U<00Izz00bZaflmc$#AMLXI#5c6It=_UB0+4D=UFVoHfybnNtdm;6=pM-
zW!8xG)Y@cdl990{H=|^=Sj@Zb`~Kw~6-K__p$4(>IF0-LUi{OGWmicRMQu%2q7^Sl

literal 0
HcmV?d00001

diff --git a/test/data/oai_conversion_v2_to_v3/tombStones.list b/test/data/oai_conversion_v2_to_v3/tombStones.list
index 735ddc6bf12c8ed41d53b8721ffb1914aac3c0c4..f729b2051234cdd6bf22aa9816cc4d3bad224fbf 100644
GIT binary patch
literal 8
PcmX>cv|Rr1X%+?m5?BLn

literal 7976
zcmXZd!vYuv07Svqwr$(CZQHhO+qP}nwr#78lO8&Inf-$oAi)0%$UqFtpbW;~48f2L
z#n24HunfoWjKGMD#K?@osEo$wjKP?U#n_C)xQxg6Ou&Rp#KcU(q)f)-Ou>{)#nep0
zv`okJ%)pGy#LUdXtjxyj%)y+@#oWxpyv)b^EWm;+#KJ7XqAbSZEWwg2#nLRpvMk5)
ztiXz_#LBF~s;tK9tihVB#oDaHx~#|gY`}(W#KvsGrfkOMY{8an#nx=Ywrt1t?7)uf
z#Ln!(uI$F{?7^Pw#op}0zU;^T9KeAb#K9cGp&Z8H9Kn$s#nBwYu^h+ooWO~k#L1k(
zshq~?oWYr##o3(0xtz!OT)>4~#Kl~~rCi44T)~xG#noKHwOq&b+`x_8#Le8ot=z`#
z+`*mP#ogS)z1+wBJivoI#KSzoqddmrJjqi$%`-g9b3D%ryvR$u%qzUgYrM`IyvbX<
z%{#oyd%VvFe8@+9%qM)xXMD~Ve92dQ%{P3@cYMze{K!xI%rE?h|MDxp@jHL;Cx7ub
z|L`vZ1pNO5WFQ7+5C&y124@I{WGIGa7=~pyhGzsuWF$sr6h>t<MrRDhWGu#J9L8ll
z#%BU1WFjVJ5+-FbCT9w!WGbd+8m47Bre_9bWF}^27G`BOW@irOWG?1r9_D2}=4SyG
zWFZ!25f)`J7H0{TWGR+r8J1-^mS+W4WF=N+6;@?6R%Z>?WG&Wa9oA(%)@K7YWFt0a
z6E<ZtHfIaAWGl928@6RTwr2-+WG8lJ7j|Vgc4rUvWH0t+ANFNG_U8Z&<RA{_5Dw)q
z4(AAt<S35j7>?yQj^_kU<Rnh!6i($dPUj5H<SfqS9M0uD&gTLy<RUKS5-#O3F6Roa
z<SMS_8m{F!uIC1B<R)(B7H;J>Zs!i}<Sy>!9`5Bn?&kp><RKpB5gz3+9_I<3<SCx!
z8J^`ip63N#<RxC_6<*~vUgr(o<SpLj9p2?V-sb~8<Rd=j6F%iLKIaR*<SV}B8@}Z`
zzUK#i<R^aS7yiS4`IX=Joj>@KzxbPf_?H0!=|2N8FoQ5CgE2TmFeF1UG{Z0~!!bM~
zFd`!{GNUjmqcJ*TFeYO$HsdfZ<1s!HFd-8$F_SPUlQB6{FeOtlHPbLH(=k0WFe5WD
zGqW%&voSk!Feh^{H}fzr^D#dQupkSuFpID#i?KLMup~>dG|R9o%dtEwup%q5GOMsE
ztFbz3vKDKz4(qZW>$3qHvJo4z37fJRo3jO5vK3pi4coFE+p_~ZvJ*SA3%jx#yR!#-
zvKM=^5Bsto`*Q#Xau5e|2#0bQhjRo+aui2%499XD$8!QFauO$V3a4@!r*j5pau#QE
z4(D<n=W_uUauFAE372vimvaSIauru|4cBrV*K-3mauYXm3%7C`w{r(~au;`V5BG8(
z_wxV`@(>U62#@j@kMjgi@)S?=4A1f$&+`H=@)9re3a|1Suk!|P@)mFN4)5|F@ACm4
z@(~~N37_&ApYsJ@@)ck64d3z|-}3`M@)JMv3;*H2{K{|q&L8~AU;NEK{L27=b)SJ4
zm_Znn!5Ew&7?PnFnqe50;TWC~7?F_}nNb*((HNaE7?ZIWn{gPI@fe>8n2?E>m`RwF
z$(Woen3AcOnrWDp>6o4wn30*7nOT^X*_fR<n3K7fn|YX*`Iw&tSdfKSm_=BW#aNsr
zSdyh!nq^p)<yf8-Sdo=jnN?Vo)mWW1Sd+C_n{`;1^;n+`*pQ9bm`&J}&DfkR*pjW-
znr+yY?bx0j*pZ#snO)eG-PoNy*pt23n|;`q{n(!aIFN%lm_s;}!#JEHIFh3{nqxSY
z<2arZIFXY$nNv8G(>R?oIFqwDn{zmq^EjUixR8sum`k{n%eb5?xRR^5nrpb0>$sj9
zxRIN<nOnG(+qj)OxRblMn|rvI`?#M6c#wy9m`8Y&$9SA4c#@}hnrC>H=XjnMc#)TQ
knOAs~*La;bc$2qyn|FAZ_jsQV_>hnIm{0hW&-k4G0Y>@j&Hw-a

-- 
1.7.2.5

