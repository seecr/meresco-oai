Changeset created on Tue Oct  5 17:27:49 CEST 2010 by Seek You Too

Description: OaiHarvester component

    This new OaiHarvester component harvests OAI from within a Meresco DNA server. It calls 'add' on an observer for each ListRecords response and supports the custom x-wait parameter to allow near real-time OAI.

Baseline version: https://meresco.svn.sourceforge.net/svnroot/meresco/meresco-oai/workingsets/3.2.1-Edurep/version_2

diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_2/meresco/oai/__init__.py version_2-oai-harvester-component/meresco/oai/__init__.py
--- version_2/meresco/oai/__init__.py	2010-10-04 11:02:33.000000000 +0200
+++ version_2-oai-harvester-component/meresco/oai/__init__.py	2010-10-04 14:19:18.000000000 +0200
@@ -35,3 +35,4 @@
 from fields2oairecord import Fields2OaiRecordTx
 from oaijazz import OaiJazz
 from oaiaddrecord import OaiAddRecord, OaiAddRecordWithDefaults
+from oaiharvester import OaiHarvester
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_2/meresco/oai/oaiharvester.py version_2-oai-harvester-component/meresco/oai/oaiharvester.py
--- version_2/meresco/oai/oaiharvester.py	1970-01-01 01:00:00.000000000 +0100
+++ version_2-oai-harvester-component/meresco/oai/oaiharvester.py	2010-10-05 17:25:01.000000000 +0200
@@ -0,0 +1,134 @@
+## begin license ##
+#
+#    Meresco Oai are components to build Oai repositories, based on Meresco
+#    Core and Meresco Components.
+#    Copyright (C) 2010 Stichting Kennisnet Ict op school.
+#       http://www.kennisnetictopschool.nl
+#
+#    This file is part of Meresco Oai.
+#
+#    Meresco Oai is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Meresco Oai is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Meresco Oai; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+import sys
+from socket import socket, error as SocketError, SHUT_WR, SHUT_RD, SOL_SOCKET, SO_ERROR
+from errno import EINPROGRESS, ECONNREFUSED
+from lxml.etree import parse
+from StringIO import StringIO
+from traceback import format_exc
+
+from meresco.core import Observable
+from weightless import compose
+
+
+namespaces = {'oai': "http://www.openarchives.org/OAI/2.0/"}
+
+class OaiHarvester(Observable):
+    def __init__(self, reactor, host, port, path, metadataPrefix, workingdir, xWait=True):
+        super(OaiHarvester, self).__init__()
+        self._reactor = reactor
+        self._host = host
+        self._port = port 
+        self._path = path
+        self._prefix = metadataPrefix
+        self._xWait = xWait
+
+    def observer_init(self):
+        self._loop = compose(self.loop())
+        self._reactor.addTimer(1, self._loop.next)
+
+    def loop(self):
+        resumptionToken = None
+        while True:
+            sok = yield self._tryConnect()
+            sok.send(self._buildRequest(resumptionToken))
+            sok.shutdown(SHUT_WR)
+            self._reactor.addReader(sok, self._loop.next)
+            responses = []
+            while True:
+                yield
+                response = sok.recv(4096)
+                if response == '':
+                     break
+                responses.append(response)
+            self._reactor.removeReader(sok)
+            sok.close()
+            try:
+                resumptionToken = self._processResponse(''.join(responses))
+            except Exception:
+                self._logError(format_exc())
+            self._reactor.addTimer(1, self._loop.next)
+            yield
+
+    def _buildRequest(self, resumptionToken):
+        request = LISTRECORDS % (self._path, self._prefix)
+        if resumptionToken:
+            request += "&resumptionToken=%s" % resumptionToken
+        if self._xWait:
+            request += "&x-wait=True"
+        return STATUSLINE % request
+
+    def _tryConnect(self):
+        sok = socket()
+        sok.setblocking(0)
+        while True:
+            try:
+                sok.connect((self._host, self._port))
+            except SocketError, (errno, msg):
+                if errno != EINPROGRESS:
+                    yield self._retryAfterError("%s: %s" % (errno, msg))
+                    continue
+            self._reactor.addWriter(sok, self._loop.next)
+            yield
+            self._reactor.removeWriter(sok)
+
+            err = sok.getsockopt(SOL_SOCKET, SO_ERROR)
+            if err == ECONNREFUSED:
+                yield self._retryAfterError("Connection to %s:%s%s refused." % (self._host, self._port, self._path))
+                continue
+            if err != 0:   # any other error
+                raise IOError(err)
+            break
+        raise StopIteration(sok)
+
+    def _retryAfterError(self, message):
+        self._logError(message)
+        self._reactor.addTimer(1, self._loop.next)
+        yield
+        
+    def _processResponse(self, response):
+        headers, body = response.split("\r\n\r\n")
+        lxmlNode = parse(StringIO(body))
+        errors = lxmlNode.xpath("/oai:OAI-PMH/oai:error", namespaces=namespaces)
+        if len(errors) > 0:
+            for error in errors:
+                self._logError("%s: %s" % (error.get("code"), error.text))
+            return None
+        else:
+            self.any.add(lxmlNode)
+            return head(lxmlNode.xpath("/oai:OAI-PMH/oai:ListRecords/oai:resumptionToken/text()", 
+                                       namespaces=namespaces))
+
+    def _logError(self, message):
+        print >> sys.stderr,  message
+
+
+def head(l):
+    return l[0] if l else None
+
+
+STATUSLINE = "GET %s HTTP/1.0\r\n\r\n"
+LISTRECORDS = "%s?verb=ListRecords&metadataPrefix=%s"
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_2/test/_alltests.py version_2-oai-harvester-component/test/_alltests.py
--- version_2/test/_alltests.py	2010-10-04 11:02:33.000000000 +0200
+++ version_2-oai-harvester-component/test/_alltests.py	2010-10-04 16:12:58.000000000 +0200
@@ -57,7 +57,7 @@
 from oaitooltest import OaiToolTest
 from resumptiontokentest import ResumptionTokenTest
 from oaipmhtest import OaiPmhTest2
-
+from oaiharvestertest import OaiHarvesterTest
 
 if __name__ == '__main__':
     unittest.main()
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_2/test/oaiharvestertest.py version_2-oai-harvester-component/test/oaiharvestertest.py
--- version_2/test/oaiharvestertest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_2-oai-harvester-component/test/oaiharvestertest.py	2010-10-05 17:26:04.000000000 +0200
@@ -0,0 +1,241 @@
+## begin license ##
+#
+#    Meresco Oai are components to build Oai repositories, based on Meresco
+#    Core and Meresco Components.
+#    Copyright (C) 2010 Stichting Kennisnet Ict op school.
+#       http://www.kennisnetictopschool.nl
+#
+#    This file is part of Meresco Oai.
+#
+#    Meresco Oai is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Meresco Oai is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Meresco Oai; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+from __future__ import with_statement
+from contextlib import contextmanager
+from random import randint
+from threading import Event, Thread
+from time import sleep
+from socket import socket, error as SocketError
+from lxml.etree import tostring
+from StringIO import StringIO
+
+from cq2utils import CQ2TestCase, CallTrace
+from meresco.core import Observable, be
+from meresco.oai import OaiHarvester
+
+@contextmanager
+def server(responses, bufsize=4096):
+    port = randint(2**10, 2**16)
+    start = Event()
+    messages = []
+    def serverThread():
+        s = socket()
+        s.bind(('127.0.0.1', port))
+        s.listen(0)
+        start.set()
+        for response in responses:
+            connection, address = s.accept()
+            msg = connection.recv(bufsize)
+            messages.append(msg)
+            connection.send(response)
+            connection.close()
+    thread = Thread(None, serverThread)
+    thread.start()
+    start.wait()
+    yield port, messages
+    thread.join()
+
+
+class OaiHarvesterTest(CQ2TestCase):
+    def testOne(self):
+        reactor = CallTrace("reactor")
+        with server([RESPONSE]) as (port, msgs):
+            harvester, observer, reactor = self.getHarvester("localhost", port, "/oai", 'dc')
+            self.assertEquals('addTimer', reactor.calledMethods[0].name)
+            self.assertEquals(1, reactor.calledMethods[0].args[0])
+            callback = reactor.calledMethods[0].args[1]
+            callback() # connect
+            self.assertEquals('addWriter', reactor.calledMethods[1].name)
+            callback = reactor.calledMethods[1].args[1]
+            callback() # HTTP GET
+            sleep(0.01)
+            self.assertEquals("GET", msgs[0][:3])
+            self.assertEquals('removeWriter', reactor.calledMethods[2].name)
+            self.assertEquals('addReader', reactor.calledMethods[3].name)
+            callback = reactor.calledMethods[3].args[1]
+            callback() # sok.recv
+            callback() # sok.recv
+            self.assertEquals('add', observer.calledMethods[0].name)
+            self.assertEqualsWS(BODY, tostring(observer.calledMethods[0].args[0]))
+
+    def testNoConnectionPossible(self):
+        harvester, observer, reactor = self.getHarvester("some.nl", 'no-port', "/oai", 'dc')
+        callback = reactor.calledMethods[0].args[1]
+        try:
+            callback() # connect
+            self.fail()
+        except TypeError, e:
+            self.assertEquals("an integer is required", str(e))
+
+    def testInvalidPortConnectionRefused(self):
+        harvester, observer, reactor = self.getHarvester("localhost", 88, "/oai", 'dc')
+        callback = reactor.calledMethods[0].args[1]
+        callback() # connect
+        self.assertEquals("addWriter", reactor.calledMethods[1].name)
+        callback() # connect
+        self.assertEquals("removeWriter", reactor.calledMethods[2].name)
+        self.assertEquals("addTimer", reactor.calledMethods[3].name)
+        self.assertEquals("Connection to localhost:88/oai refused.\n", self._err.getvalue())
+
+    def testInvalidHost(self):
+        harvester, observer, reactor = self.getHarvester("UEYR^$*FD(#>NDJ.khfd9.(*njnd", 88, "/oai", 'dc')
+        callback = reactor.calledMethods[0].args[1]
+        callback() # connect
+        self.assertEquals('addTimer', reactor.calledMethods[-1].name)
+        self.assertEquals("-2: Name or service not known\n", self._err.getvalue())
+
+    def testInvalidHostConnectionRefused(self):
+        harvester, observer, reactor = self.getHarvester("127.0.0.255", 9876, "/oai", 'dc')
+        callback = reactor.calledMethods[0].args[1]
+        callback()
+        self.assertEquals("addWriter", reactor.calledMethods[1].name)
+        callback()
+        self.assertEquals("removeWriter", reactor.calledMethods[2].name)
+        self.assertEquals("addTimer", reactor.calledMethods[3].name)
+
+    def testSuccess(self):
+        with server([RESPONSE]) as (port, msgs):
+            harvester, observer, reactor = self.getHarvester("localhost", port, "/", "dc")
+            callback = self.doConnect()
+            callback() # HTTP GET
+            sleep(0.01)
+            callback = reactor.calledMethods[3].args[1]
+            callback() # sok.recv
+            callback() # recv = ''
+            self.assertEquals('add', observer.calledMethods[0].name)
+            self.assertEqualsWS(BODY, tostring(observer.calledMethods[0].args[0]))
+            self.assertEquals('removeReader', reactor.calledMethods[4].name)
+            self.assertEquals('addTimer', reactor.calledMethods[-1].name)
+
+    def testListRecordsRequest(self):
+        with server([LISTRECORDS_RESPONSE % '']) as (port, msgs):
+            harvester, observer, reactor = self.getHarvester('localhost', port, '/oai', 'dc', xWait=False)
+            callback = self.doConnect()
+            callback() # HTTP GET
+            sleep(0.01)
+            self.assertEquals("GET /oai?verb=ListRecords&metadataPrefix=dc HTTP/1.0\r\n\r\n", msgs[0])
+
+    def testListRecordsRequestError(self):
+        with server([ERROR_RESPONSE]) as (port, msgs):
+            harvester, observer, reactor = self.getHarvester('localhost', port, '/oai', 'dc')
+            callback = self.doConnect()
+            callback() # HTTP GET
+            sleep(0.01)
+            callback() # sok.recv
+            callback() # sok.recv == ''
+            self.assertEquals("someError: Some error occurred.\n", self._err.getvalue())
+            self.assertEquals(0, len(observer.calledMethods))
+            self.assertEquals('addTimer', reactor.calledMethods[-1].name)
+    
+    def testUseResumptionToken(self):
+        with server([LISTRECORDS_RESPONSE % RESUMPTION_TOKEN, LISTRECORDS_RESPONSE % ""]) as (port, msgs):
+            harvester, observer, reactor = self.getHarvester('localhost', port, '/oai', 'dc')
+            callback = self.doConnect()
+            callback() # HTTP GET
+            sleep(0.01)
+            self.assertEquals("GET /oai?verb=ListRecords&metadataPrefix=dc&x-wait=True HTTP/1.0\r\n\r\n", msgs[0])
+            callback() # sok.recv
+            callback() # sok.recv == ''
+            self.assertEquals(['add'], [m.name for m in observer.calledMethods])
+            self.assertEquals('addTimer', reactor.calledMethods[-1].name)            
+            callback() # (re)connect
+            callback() # HTTP GET
+            sleep(0.01)
+            self.assertEquals("GET /oai?verb=ListRecords&metadataPrefix=dc&resumptionToken=xyz&x-wait=True HTTP/1.0\r\n\r\n", msgs[1])
+
+    def testKeepResumptionTokenOnInvalidResponse(self):
+        with server([LISTRECORDS_RESPONSE % RESUMPTION_TOKEN, STATUSLINE + 'not XML']) as (port, msgs):
+            harvester, observer, reactor = self.getHarvester('localhost', port, '/oai', 'dc')
+            callback = self.doConnect()
+            callback() # HTTP GET
+            sleep(0.01)
+            self.assertEquals("GET /oai?verb=ListRecords&metadataPrefix=dc&x-wait=True HTTP/1.0\r\n\r\n", msgs[0])
+            callback() # sok.recv
+            callback() # soc.recv == ''
+            callback() # (re)connect
+            callback() # HTTP GET
+            sleep(0.01)
+            self.assertEquals("GET /oai?verb=ListRecords&metadataPrefix=dc&resumptionToken=xyz&x-wait=True HTTP/1.0\r\n\r\n", msgs[-1])
+            callback() # sok.recv
+            callback() # sok.recv == ''
+            self.assertTrue("XMLSyntaxError: Start tag expected, '<' not found, line 1, column 1" in self._err.getvalue(), self._err.getvalue())
+            callback() # (re)connect
+            callback() # HTTP GET
+            sleep(0.01)
+            self.assertEquals("GET /oai?verb=ListRecords&metadataPrefix=dc&resumptionToken=xyz&x-wait=True HTTP/1.0\r\n\r\n", msgs[-1])
+
+
+    def getHarvester(self, host, port, path, metadataPrefix, xWait=True):
+        self._err = StringIO()
+        self._reactor = CallTrace("reactor")
+        self._harvester = OaiHarvester(self._reactor, host, port, path, metadataPrefix, self.tempdir, xWait=xWait)
+        self._harvester._logError = lambda s: self._err.write(s + '\n')
+        self._observer = CallTrace("observer")
+        self._harvester.addObserver(self._observer)
+        self._harvester.observer_init()
+        return self._harvester, self._observer, self._reactor
+
+    def doConnect(self):
+        callback = self._reactor.calledMethods[0].args[1]
+        callback() # connect
+        callback = self._reactor.calledMethods[1].args[1]
+        return callback
+
+STATUSLINE = """HTTP/1.0 200 OK \r\n\r\n"""
+BODY = "<body>BODY</body>"
+RESPONSE = STATUSLINE + BODY
+
+LISTRECORDS_RESPONSE = STATUSLINE + """<?xml version="1.0" encoding="UTF-8" ?>
+<OAI-PMH xmlns="http://www.openarchives.org/OAI/2.0/" 
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://www.openarchives.org/OAI/2.0/
+         http://www.openarchives.org/OAI/2.0/OAI-PMH.xsd">
+  <responseDate>2002-06-01T19:20:30Z</responseDate>
+  <request verb="ListRecords" from="1998-01-15" 
+           metadataPrefix="dc">http://an.oa.org/OAI-script</request>
+  <ListRecords>
+    <record>ignored</record>
+    %s
+  </ListRecords>
+</OAI-PMH>
+"""
+
+ERROR_RESPONSE = STATUSLINE + """<?xml version="1.0" encoding="UTF-8" ?>
+<OAI-PMH xmlns="http://www.openarchives.org/OAI/2.0/" 
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://www.openarchives.org/OAI/2.0/
+         http://www.openarchives.org/OAI/2.0/OAI-PMH.xsd">
+  <responseDate>2002-06-01T19:20:30Z</responseDate>
+  <request verb="ListRecords" from="1998-01-15" 
+           metadataPrefix="dc">http://an.oa.org/OAI-script</request>
+  <error code="someError">Some error occurred.</error>
+</OAI-PMH>
+"""
+ 
+RESUMPTION_TOKEN = """<resumptionToken expirationDate="2002-06-01T23:20:00Z" 
+      completeListSize="6" 
+      cursor="0">xyz</resumptionToken>"""
+
