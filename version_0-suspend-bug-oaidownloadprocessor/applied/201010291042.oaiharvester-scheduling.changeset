Changeset created on Fri Oct 29 10:42:10 CEST 2010 by Seek You Too

Description: OaiHarvester scheduling support added

    The OaiHarvester previously processed all records from a ListRecords
    response in a single do.add(...) call.  Since do-calls are intentionally
    uninterruptible, this blocked the service containing the OaiHarvester
    too long.
    The ListRecords response is now handled on a per-record basis,
    scheduled by the Reactor (optionally with a specified priority);
    including a matching UpdateAdapterFromOaiHarvester.

Baseline version: https://meresco.svn.sourceforge.net/svnroot/meresco/meresco-oai/workingsets/3.3-Edurep/version_3

diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_3/meresco/oai/__init__.py version_4/meresco/oai/__init__.py
--- version_3/meresco/oai/__init__.py	2010-10-19 11:24:06.000000000 +0200
+++ version_4/meresco/oai/__init__.py	2010-10-29 10:40:51.000000000 +0200
@@ -37,4 +37,4 @@
 from oaiaddrecord import OaiAddRecord, OaiAddRecordWithDefaults
 from oaisuspend import OaiSuspend
 from oaiharvester import OaiHarvester
-
+from updateadapter import UpdateAdapterFromOaiHarvester
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_3/meresco/oai/oaiharvester.py version_4/meresco/oai/oaiharvester.py
--- version_3/meresco/oai/oaiharvester.py	2010-10-28 11:37:06.000000000 +0200
+++ version_4/meresco/oai/oaiharvester.py	2010-10-29 10:40:51.000000000 +0200
@@ -23,23 +23,37 @@
 #
 ## end license ##
 
-import sys
 from socket import socket, error as SocketError, SHUT_WR, SHUT_RD, SOL_SOCKET, SO_ERROR
 from errno import EINPROGRESS, ECONNREFUSED
-from lxml.etree import parse
+from lxml.etree import parse, ElementTree
 from StringIO import StringIO
 from traceback import format_exc
-from os import makedirs
+from os import makedirs, close, remove
 from os.path import join, isfile, isdir
 
 from meresco.core import Observable
 from weightless import compose
 
+from sys import stderr, stdout
+from time import time
+from tempfile import mkstemp
+
+class AlwaysReadable(object):
+    def __init__(self):
+        self._fd, self._name = mkstemp('oaiharvester')
+
+    def fileno(self):
+        return self._fd
+
+    def cleanUp(self):
+        close(self._fd)
+        remove(self._name)
+
 
 namespaces = {'oai': "http://www.openarchives.org/OAI/2.0/"}
 
 class OaiHarvester(Observable):
-    def __init__(self, reactor, host, port, path, metadataPrefix, workingDir, xWait=True):
+    def __init__(self, reactor, host, port, path, metadataPrefix, workingDir, xWait=True, verbose=False, prio=None):
         super(OaiHarvester, self).__init__()
         self._reactor = reactor
         self._host = host
@@ -48,7 +62,11 @@
         self._prefix = metadataPrefix
         isdir(workingDir) or makedirs(workingDir)
         self._xWait = xWait
+        self._prio = prio
         self._stateFilePath = join(workingDir, "harvester.state")
+        if not verbose:
+            self._log = lambda x: None
+            self._logError = lambda x: None
 
     def observer_init(self):
         resumptionToken = self._readState()
@@ -60,7 +78,7 @@
             sok = yield self._tryConnect()
             sok.send(self._buildRequest(resumptionToken))
             sok.shutdown(SHUT_WR)
-            self._reactor.addReader(sok, self._loop.next)
+            self._reactor.addReader(sok, self._loop.next, prio=self._prio)
             responses = []
             while True:
                 yield
@@ -70,12 +88,31 @@
                 responses.append(response)
             self._reactor.removeReader(sok)
             sok.close()
+            alwaysReadable = AlwaysReadable()
             try:
-                resumptionToken = self._processResponse(''.join(responses))
+                response = ''.join(responses)
+                headers, body = response.split("\r\n\r\n")
+                lxmlNode = parse(StringIO(body))
+                errors = xpath(lxmlNode, "/oai:OAI-PMH/oai:error")
+                if len(errors) > 0:
+                    for error in errors:
+                        self._logError("%s: %s" % (error.get("code"), error.text))
+                    resumptionToken = None
+                else:
+                    self._reactor.addReader(alwaysReadable, self._loop.next, prio=self._prio)
+                    try:
+                        records = xpath(lxmlNode, '/oai:OAI-PMH/oai:ListRecords/oai:record')
+                        for record in records:
+                            self.do.add(lxmlNode=ElementTree(record))
+                            yield
+                    finally:
+                        self._reactor.removeReader(alwaysReadable)
+                    resumptionToken = head(xpath(lxmlNode, "/oai:OAI-PMH/oai:ListRecords/oai:resumptionToken/text()"))
             except Exception:
                 self._logError(format_exc())
             finally:
                 open(self._stateFilePath, 'w').write("Resumptiontoken: %s" % resumptionToken)
+                alwaysReadable.cleanUp()
             self._reactor.addTimer(1, self._loop.next)
             yield
 
@@ -123,26 +160,21 @@
         self._reactor.addTimer(1, self._loop.next)
         yield
         
-    def _processResponse(self, response):
-        headers, body = response.split("\r\n\r\n")
-        lxmlNode = parse(StringIO(body))
-        errors = lxmlNode.xpath("/oai:OAI-PMH/oai:error", namespaces=namespaces)
-        if len(errors) > 0:
-            for error in errors:
-                self._logError("%s: %s" % (error.get("code"), error.text))
-            return None
-        else:
-            self.do.add(lxmlNode=lxmlNode)
-            return head(lxmlNode.xpath("/oai:OAI-PMH/oai:ListRecords/oai:resumptionToken/text()", 
-                                       namespaces=namespaces))
 
     def _logError(self, message):
-        print >> sys.stderr,  message
+        stderr.write(message)
+        stderr.flush()
+
+    def _log(self, message):
+        stdout.write(message)
+        stdout.flush()
 
 
 def head(l):
     return l[0] if l else ""
 
+def xpath(node, path):
+    return node.xpath(path, namespaces=namespaces)
 
 STATUSLINE = "GET %s HTTP/1.0\r\n\r\n"
 LISTRECORDS = "%s?verb=ListRecords"
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_3/meresco/oai/updateadapter.py version_4/meresco/oai/updateadapter.py
--- version_3/meresco/oai/updateadapter.py	1970-01-01 01:00:00.000000000 +0100
+++ version_4/meresco/oai/updateadapter.py	2010-10-29 10:40:51.000000000 +0200
@@ -0,0 +1,47 @@
+## begin license ##
+#
+#    Meresco Oai are components to build Oai repositories, based on Meresco
+#    Core and Meresco Components.
+#    Copyright (C) 2010 Seek You Too (CQ2) http://www.cq2.nl
+#    Copyright (C) 2010 Stichting Kennisnet http://www.kennisnet.nl
+#
+#    This file is part of Meresco Oai.
+#
+#    Meresco Oai is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Meresco Oai is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Meresco Oai; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+from meresco.core import Observable
+
+namespaces = {
+    'oai': 'http://www.openarchives.org/OAI/2.0/'
+}
+
+class UpdateAdapterFromOaiHarvester(Observable):
+
+    def add(self, lxmlNode):
+        header = xpath(lxmlNode, '/oai:record/oai:header')
+        if not header:
+            raise ValueError("Expected /{%(oai)s}record/{%(oai)s}header" % namespaces)
+        header = header[0]
+        identifier = xpath(header, 'oai:identifier/text()')[0]
+        if xpath(header, 'self::node()[@status="deleted"]'):
+            return self.all.delete(identifier=identifier)
+        else:
+            return self.all.add(identifier=identifier, partname='record', lxmlNode=lxmlNode)
+
+
+def xpath(node, path):
+    return node.xpath(path, namespaces=namespaces)
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_3/test/_alltests.py version_4/test/_alltests.py
--- version_3/test/_alltests.py	2010-10-19 11:24:06.000000000 +0200
+++ version_4/test/_alltests.py	2010-10-29 10:40:51.000000000 +0200
@@ -45,20 +45,21 @@
 from fields2oairecordtest import Fields2OaiRecordTest
 from oaiaddrecordtest import OaiAddRecordTest
 from oaigetrecordtest import OaiGetRecordTest
+from oaiharvestertest import OaiHarvesterTest
 from oaijazzimplementationstest import OaiJazzImplementationsTest
 from oaijazztest import OaiJazzTest
 from oailistmetadataformatstest import OaiListMetadataFormatsTest
 from oailistsetstest import OaiListSetsTest
 from oailisttest import OaiListTest
 from oaipmhjazztest import OaiPmhJazzTest
+from oaipmhtest import OaiPmhTest2
 from oaipmhtest import OaiPmhTest, OaiPmhWithIdentifierTest
 from oaiprovenancetest import OaiProvenanceTest
-from oaisuspendtest import OaiSuspendTest
 from oaisetselecttest import OaiSetSelectTest
+from oaisuspendtest import OaiSuspendTest
 from oaitooltest import OaiToolTest
 from resumptiontokentest import ResumptionTokenTest
-from oaipmhtest import OaiPmhTest2
-from oaiharvestertest import OaiHarvesterTest
+from updateadaptertest import UpdateAdapterTest
 
 if __name__ == '__main__':
     unittest.main()
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_3/test/oaiharvestertest.py version_4/test/oaiharvestertest.py
--- version_3/test/oaiharvestertest.py	2010-10-19 11:24:06.000000000 +0200
+++ version_4/test/oaiharvestertest.py	2010-10-29 10:40:51.000000000 +0200
@@ -39,7 +39,7 @@
 
 @contextmanager
 def server(responses, bufsize=4096):
-    port = randint(2**10, 2**16)
+    port = randint(10000,60000)
     start = Event()
     messages = []
     def serverThread():
@@ -63,7 +63,7 @@
 class OaiHarvesterTest(CQ2TestCase):
     def testOne(self):
         reactor = CallTrace("reactor")
-        with server([RESPONSE]) as (port, msgs):
+        with server([RESPONSE_ONE_RECORD]) as (port, msgs):
             harvester, observer, reactor = self.getHarvester("localhost", port, "/oai", 'dc')
             self.assertEquals('addTimer', reactor.calledMethods[0].name)
             self.assertEquals(1, reactor.calledMethods[0].args[0])
@@ -76,13 +76,15 @@
             self.assertEquals("GET", msgs[0][:3])
             self.assertEquals('removeWriter', reactor.calledMethods[2].name)
             self.assertEquals('addReader', reactor.calledMethods[3].name)
+            self.assertEquals(0, reactor.calledMethods[3].kwargs['prio'])
             callback = reactor.calledMethods[3].args[1]
             callback() # sok.recv
             callback() # sok.recv
+            callback() # yield after self.do.add(...
             self.assertEquals('add', observer.calledMethods[0].name)
             self.assertFalse(len(observer.calledMethods[0].args))
             self.assertEquals(['lxmlNode'], observer.calledMethods[0].kwargs.keys())
-            self.assertEqualsWS(BODY, tostring(observer.calledMethods[0].kwargs['lxmlNode']))
+            self.assertEqualsWS(ONE_RECORD, tostring(observer.calledMethods[0].kwargs['lxmlNode']))
 
     def testNoConnectionPossible(self):
         harvester, observer, reactor = self.getHarvester("some.nl", 'no-port', "/oai", 'dc')
@@ -120,7 +122,7 @@
         self.assertEquals("addTimer", reactor.calledMethods[3].name)
 
     def testSuccess(self):
-        with server([RESPONSE]) as (port, msgs):
+        with server([RESPONSE_TWO_RECORDS]) as (port, msgs):
             harvester, observer, reactor = self.getHarvester("localhost", port, "/", "dc")
             callback = self.doConnect()
             callback() # HTTP GET
@@ -128,13 +130,16 @@
             callback = reactor.calledMethods[3].args[1]
             callback() # sok.recv
             callback() # recv = ''
+            callback() # yield after self.do.add(...
+            callback() # yield after self.do.add(...
             self.assertEquals('add', observer.calledMethods[0].name)
-            self.assertEqualsWS(BODY, tostring(observer.calledMethods[0].kwargs['lxmlNode']))
-            self.assertEquals('removeReader', reactor.calledMethods[4].name)
+            self.assertEquals('add', observer.calledMethods[1].name)
+            self.assertEqualsWS(ONE_RECORD, tostring(observer.calledMethods[0].kwargs['lxmlNode']))
+            self.assertEquals('removeReader', reactor.calledMethods[-2].name)
             self.assertEquals('addTimer', reactor.calledMethods[-1].name)
 
     def testSuccessWithMoreObservers(self):
-        with server([RESPONSE]) as (port, msgs):
+        with server([RESPONSE_ONE_RECORD]) as (port, msgs):
             harvester, observer, reactor = self.getHarvester("localhost", port, "/", "dc")
             anotherObserver = CallTrace('another observer')
             harvester.addObserver(anotherObserver)
@@ -145,6 +150,7 @@
             callback = reactor.calledMethods[3].args[1]
             callback() # sok.recv
             callback() # recv = ''
+            callback() # yield after self.do.add(...
             
             self.assertEquals('add', observer.calledMethods[0].name)
             self.assertEquals('add', anotherObserver.calledMethods[0].name)
@@ -179,6 +185,7 @@
             callback() # sok.recv
             callback() # sok.recv == ''
             self.assertEquals(['add'], [m.name for m in observer.calledMethods])
+            callback() # removeReader() after self.do.add(...
             self.assertEquals('addTimer', reactor.calledMethods[-1].name)
             self.assertEquals('Resumptiontoken: xyz', open(self._harvester._stateFilePath).read())
             callback() # (re)connect
@@ -187,6 +194,7 @@
             self.assertEquals("GET /oai?verb=ListRecords&resumptionToken=xyz&x-wait=True HTTP/1.0\r\n\r\n", msgs[1])
             callback() # sok.recv
             callback() # sok.recv == ''
+            callback() # removeReader() after self.do.add(...
             self.assertEquals('Resumptiontoken: ', open(self._harvester._stateFilePath).read())
 
     def testKeepResumptionTokenOnRestart(self):
@@ -198,6 +206,7 @@
             self.assertEquals("GET /oai?verb=ListRecords&metadataPrefix=dc&x-wait=True HTTP/1.0\r\n\r\n", msgs[0])
             callback() # sok.recv
             callback() # sok.recv == ''
+            callback() # removeReader() after self.do.add(...
             self.assertEquals('Resumptiontoken: xyz', open(self._harvester._stateFilePath).read())
         with server([LISTRECORDS_RESPONSE % RESUMPTION_TOKEN]) as (port, msgs):
             harvester, observer, reactor = self.getHarvester('localhost', port, '/oai', 'dc')
@@ -215,6 +224,7 @@
             self.assertEquals("GET /oai?verb=ListRecords&metadataPrefix=dc&x-wait=True HTTP/1.0\r\n\r\n", msgs[0])
             callback() # sok.recv
             callback() # soc.recv == ''
+            callback() # removeReader() after self.do.add(...
             self.assertEquals('Resumptiontoken: xyz', open(self._harvester._stateFilePath).read())
             callback() # (re)connect
             callback() # HTTP GET
@@ -222,6 +232,7 @@
             self.assertEquals("GET /oai?verb=ListRecords&resumptionToken=xyz&x-wait=True HTTP/1.0\r\n\r\n", msgs[-1])
             callback() # sok.recv
             callback() # sok.recv == ''
+            callback() # removeReader() after self.do.add(...
             self.assertTrue("XMLSyntaxError: Start tag expected, '<' not found, line 1, column 1" in self._err.getvalue(), self._err.getvalue())
             self.assertEquals('Resumptiontoken: xyz', open(self._harvester._stateFilePath).read())
             callback() # (re)connect
@@ -249,7 +260,7 @@
             workingDir = join(self.tempdir, 'harvesterstate')
         self._err = StringIO()
         self._reactor = CallTrace("reactor")
-        self._harvester = OaiHarvester(self._reactor, host, port, path, metadataPrefix, workingDir=workingDir, xWait=xWait)
+        self._harvester = OaiHarvester(self._reactor, host, port, path, metadataPrefix, workingDir=workingDir, xWait=xWait, prio=0)
         self._harvester._logError = lambda s: self._err.write(s + '\n')
         self._observer = CallTrace("observer")
         self._harvester.addObserver(self._observer)
@@ -263,8 +274,16 @@
         return callback
 
 STATUSLINE = """HTTP/1.0 200 OK \r\n\r\n"""
-BODY = "<body>BODY</body>"
-RESPONSE = STATUSLINE + BODY
+EMBEDDED_RECORD = '<record>ignored</record>\n'
+ONE_RECORD = '<record xmlns="http://www.openarchives.org/OAI/2.0/">ignored</record>'
+BODY = """<OAI-PMH xmlns="http://www.openarchives.org/OAI/2.0/">
+    <ListRecords>
+        %s
+    </ListRecords>
+</OAI-PMH>
+"""
+RESPONSE_ONE_RECORD = STATUSLINE + BODY % EMBEDDED_RECORD
+RESPONSE_TWO_RECORDS = STATUSLINE + BODY % (EMBEDDED_RECORD *2)
 
 LISTRECORDS_RESPONSE = STATUSLINE + """<?xml version="1.0" encoding="UTF-8" ?>
 <OAI-PMH xmlns="http://www.openarchives.org/OAI/2.0/" 
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_3/test/oaisuspendtest.py version_4/test/oaisuspendtest.py
--- version_3/test/oaisuspendtest.py	2010-10-20 15:35:44.000000000 +0200
+++ version_4/test/oaisuspendtest.py	2010-10-29 10:40:51.000000000 +0200
@@ -96,21 +96,20 @@
         requests = 3
         sleep(1.0 + 1.0 * requests)
        
-        self.assertEquals(2, len(observer.calledMethods))
-        kwarg = tostring(observer.calledMethods[0].kwargs['lxmlNode'])
-        self.assertTrue("id0" in kwarg, kwarg)
-        self.assertTrue("id1" in kwarg, kwarg)
-        kwarg = tostring(observer.calledMethods[1].kwargs['lxmlNode'])
-        self.assertTrue("id2" in kwarg, kwarg)
+        self.assertEquals(['add'] * requests, [m.name for m in observer.calledMethods])
+        ids = [xpath(m.kwargs['lxmlNode'], '//oai:header/oai:identifier/text()') for m in observer.calledMethods]
+        self.assertEquals([['id0'],['id1'],['id2']], ids)
 
         self.assertEquals(1, len(oaiJazz._suspended))
 
+        requests += 1
         storageComponent.add("id3", "prefix", "<a>a3</a>")
         oaiJazz.addOaiRecord(identifier="id3", sets=[], metadataFormats=[("prefix", "", "")])
         sleep(0.1)
+
         self.assertEquals(0, len(oaiJazz._suspended))
-        self.assertEquals(3, len(observer.calledMethods))
-        kwarg = tostring(observer.calledMethods[2].kwargs['lxmlNode'])
+        self.assertEquals(['add'] * requests, [m.name for m in observer.calledMethods])
+        kwarg = tostring(observer.calledMethods[-1].kwargs['lxmlNode'])
         self.assertTrue("id3" in kwarg, kwarg)
         sleep(1.0)
         self.assertEquals(1, len(oaiJazz._suspended))
@@ -204,3 +203,7 @@
         tick()
         while self.run:
             reactor.step()
+
+def xpath(node, path):
+    return node.xpath(path, namespaces={'oai':'http://www.openarchives.org/OAI/2.0/'})
+
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_3/test/updateadaptertest.py version_4/test/updateadaptertest.py
--- version_3/test/updateadaptertest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_4/test/updateadaptertest.py	2010-10-29 10:40:51.000000000 +0200
@@ -0,0 +1,79 @@
+## begin license ##
+#
+#    Meresco Oai are components to build Oai repositories, based on Meresco
+#    Core and Meresco Components.
+#    Copyright (C) 2010 Seek You Too (CQ2) http://www.cq2.nl
+#    Copyright (C) 2010 Stichting Kennisnet http://www.kennisnet.nl
+#
+#    This file is part of Meresco Oai.
+#
+#    Meresco Oai is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Meresco Oai is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Meresco Oai; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from cq2utils import CQ2TestCase, CallTrace
+
+from lxml.etree import parse
+from StringIO import StringIO
+
+from meresco.oai import UpdateAdapterFromOaiHarvester
+
+class UpdateAdapterTest(CQ2TestCase):
+    def testDelete(self):
+        adapter = UpdateAdapterFromOaiHarvester()
+        observer = CallTrace('observer')
+        adapter.addObserver(observer)
+
+        list(adapter.add(lxmlNode=parse(StringIO(OAI_DELETED_RECORD))))
+
+        self.assertEquals(['delete'], [m.name for m in observer.calledMethods])
+        self.assertEquals({'identifier':'oai:test:identifier'}, observer.calledMethods[0].kwargs)
+
+    def testAdd(self):
+        adapter = UpdateAdapterFromOaiHarvester()
+        observer = CallTrace('observer')
+        adapter.addObserver(observer)
+
+        recordNode = parse(StringIO(OAI_RECORD))
+        list(adapter.add(lxmlNode=recordNode))
+
+        self.assertEquals(['add'], [m.name for m in observer.calledMethods])
+        kwargs = observer.calledMethods[0].kwargs
+        self.assertEquals({'identifier': 'oai:test:identifier',
+            'partname': 'record',
+            'lxmlNode': recordNode}, kwargs)
+
+    def testRaiseErrorOnBadArguments(self):
+        adapter = UpdateAdapterFromOaiHarvester()
+        observer = CallTrace('observer')
+        adapter.addObserver(observer)
+
+        self.assertRaises(ValueError, adapter.add, lxmlNode=parse(StringIO('<nooairecord/>')))
+
+
+OAI_DELETED_RECORD = """<oai:record xmlns:oai="http://www.openarchives.org/OAI/2.0/">
+    <oai:header status="deleted">
+            <oai:identifier>oai:test:identifier</oai:identifier>
+            <oai:datestamp>2010-10-19T09:57:32Z</oai:datestamp>
+    </oai:header>
+</oai:record>"""
+
+OAI_RECORD = """<oai:record xmlns:oai="http://www.openarchives.org/OAI/2.0/">
+    <oai:header>
+            <oai:identifier>oai:test:identifier</oai:identifier>
+            <oai:datestamp>2010-10-19T09:57:32Z</oai:datestamp>
+    </oai:header>
+    <oai:metadata><somedata xmlns="http://example.org">DATA</somedata></oai:metadata>
+</oai:record>"""
+
