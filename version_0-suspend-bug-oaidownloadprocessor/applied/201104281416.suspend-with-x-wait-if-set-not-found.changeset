Changeset created on Thu Apr 28 14:16:07 CEST 2011 by Seek You Too

Description: x-wait now always suspend if no records are found

    If the cannotDisseminateFormat error is raised a ListRecord call with x-wait 
    now also suspends the connection. 

    Replaces AlwaysReadable in the PeriodicDownload with a TemporaryFile object

Baseline version: https://meresco.svn.sourceforge.net/svnroot/meresco/meresco-oai/workingsets/3.6.1-Edurep/version_0

diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_0/meresco/oai/oailist.py version_1/meresco/oai/oailist.py
--- version_0/meresco/oai/oailist.py	2011-04-21 11:51:20.000000000 +0200
+++ version_1/meresco/oai/oailist.py	2011-04-28 14:15:40.000000000 +0200
@@ -109,7 +109,8 @@
                 results = self._preProcess(validatedArguments, **httpkwargs)
                 break
             except OaiException, e:
-                if e.statusCode == "noRecordsMatch" and validatedArguments.get("x-wait", 'False') == 'True':
+                if validatedArguments.get("x-wait", 'False') == 'True' and \
+                        e.statusCode in ["noRecordsMatch", "cannotDisseminateFormat"]:
                     yield self.all.suspend()
                 else:
                     yield oaiError(e.statusCode, e.additionalMessage, arguments, **httpkwargs)
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_0/meresco/oai/periodicdownload.py version_1/meresco/oai/periodicdownload.py
--- version_0/meresco/oai/periodicdownload.py	2011-04-21 11:51:20.000000000 +0200
+++ version_1/meresco/oai/periodicdownload.py	2011-04-28 14:15:40.000000000 +0200
@@ -38,19 +38,7 @@
 
 from sys import stderr, stdout
 from time import time
-from tempfile import mkstemp
-
-class AlwaysReadable(object):
-    def __init__(self):
-        self._fd, self._name = mkstemp('periodicdownload')
-
-    def fileno(self):
-        return self._fd
-
-    def cleanUp(self):
-        close(self._fd)
-        remove(self._name)
-
+from tempfile import TemporaryFile
 
 class PeriodicDownload(Observable):
     def __init__(self, reactor, host, port, period=1, verbose=False, prio=None, err=None):
@@ -95,14 +83,13 @@
                     yield self._retryAfterError('Unexpected response: ' + statusLine)
                     continue
                 lxmlNode = parse(StringIO(body))
-                alwaysReadable = AlwaysReadable()
+                alwaysReadable = TemporaryFile(prefix='meresco-oai-', suffix='-download')
                 self._reactor.addReader(alwaysReadable, self._loop.next, prio=self._prio)
                 try:
                     result = self.any.handle(lxmlNode=lxmlNode)
                     yield result 
                 finally:
                     self._reactor.removeReader(alwaysReadable)
-                    alwaysReadable.cleanUp()
             except Exception:
                 self._logError(format_exc())
             self._reactor.addTimer(self._period, self._loop.next)
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_0/meresco/oai/updateadapter.py version_1/meresco/oai/updateadapter.py
--- version_0/meresco/oai/updateadapter.py	2011-04-21 11:51:20.000000000 +0200
+++ version_1/meresco/oai/updateadapter.py	2011-04-28 14:15:40.000000000 +0200
@@ -38,6 +38,7 @@
             raise ValueError("Expected /{%(oai)s}record/{%(oai)s}header" % namespaces)
         header = header[0]
         identifier = xpath(header, 'oai:identifier/text()')[0]
+        __callstack_var_identifier = identifier
         if xpath(header, 'self::node()[@status="deleted"]'):
             return self.all.delete(identifier=identifier)
         else:
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_0/test/oailisttest.py version_1/test/oailisttest.py
--- version_0/test/oailisttest.py	2011-04-21 11:51:20.000000000 +0200
+++ version_1/test/oailisttest.py	2011-04-28 14:15:40.000000000 +0200
@@ -55,6 +55,7 @@
         self.observer = CallTrace('observer')
         self.observer.returnValues['getAllPrefixes'] = ['oai_dc']
         self.observer.returnValues['oaiSelect'] = (f for f in [])
+        self.observer.returnValues['suspend'] = 'SUSPEND'
         def oaiRecord(recordId, metadataPrefix):
             return '<mock:record xmlns:mock="uri:mock">%s/%s</mock:record>' % (escapeXml(recordId), escapeXml(metadataPrefix))
         self.observer.methods['oaiRecord'] = oaiRecord
@@ -173,6 +174,29 @@
         recordMethods = self.observer.calledMethods[2:]
         self.assertEquals({'recordId':'id:1&1', 'metadataPrefix':'oai_dc'}, recordMethods[0].kwargs)
 
+    def testListRecordsUsingXWaitWhenSetNotFound(self):
+        self.oaiList = OaiList(batchSize=2, supportXWait=True)
+        self.oaiList.addObserver(self.observer)
+
+        result = compose(self.oaiList.listRecords(arguments={'verb':['ListRecords'], 'metadataPrefix': ['other_prefix'], 'x-wait': ['True']}, **self.httpkwargs))
+        suspend = result.next()
+        self.assertEquals(['getAllPrefixes', 'suspend'], [m.name for m in self.observer.calledMethods])
+        self.observer.returnValues['getAllPrefixes'] = ['other_prefix']
+        suspend = result.next() 
+        self.observer.returnValues['oaiSelect'] = WrapIterable(f for f in ['id:1&1'])
+        del self.observer.calledMethods[:]
+
+        header, body = ''.join(compose(result)).split(CRLF*2)
+        oai = parse(StringIO(body))
+
+        self.assertEquals(1, len(xpath(oai, '/oai:OAI-PMH/oai:ListRecords/mock:record')))
+        self.assertEquals(1, len(xpath(oai, '/oai:OAI-PMH/oai:ListRecords/oai:resumptionToken/text()')))
+        self.assertEquals(['getAllPrefixes', 'oaiSelect', 'oaiRecord', 'getUnique'], [m.name for m in self.observer.calledMethods])
+        selectMethod = self.observer.calledMethods[1]
+        self.assertEquals({'continueAfter':'0', 'oaiUntil':None, 'prefix':'other_prefix', 'oaiFrom':None, 'sets':None}, selectMethod.kwargs)
+        recordMethods = self.observer.calledMethods[2:]
+        self.assertEquals({'recordId':'id:1&1', 'metadataPrefix':'other_prefix'}, recordMethods[0].kwargs)
+
     def testNotSupportedXWait(self):
         self.observer.returnValues['oaiSelect'] = WrapIterable(f for f in ['id:1', 'id:2'])
         header, body = ''.join(compose(self.oaiList.listRecords(arguments={'verb':['ListRecords'], 'metadataPrefix': ['oai_dc'], 'x-wait': ['True']}, **self.httpkwargs))).split(CRLF*2)
