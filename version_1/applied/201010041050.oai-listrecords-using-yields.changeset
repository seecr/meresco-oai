Changeset created on Mon Oct  4 10:50:54 CEST 2010 by Seek You Too

Description: Oai ListRecords using yields

    Oai ListRecords now uses yield statements instead of WebRequestServer-writes.

Baseline version: meresco-oai/workingsets/3.2.1-Edurep/version_1

diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_1/meresco/oai/oaierror.py version_2/meresco/oai/oaierror.py
--- version_1/meresco/oai/oaierror.py	1970-01-01 01:00:00.000000000 +0100
+++ version_2/meresco/oai/oaierror.py	2010-10-04 10:50:13.000000000 +0200
@@ -0,0 +1,81 @@
+## begin license ##
+#
+#    Meresco Oai are components to build Oai repositories, based on Meresco
+#    Core and Meresco Components.
+#    Copyright (C) 2007-2008 SURF Foundation. http://www.surf.nl
+#    Copyright (C) 2007-2009 Stichting Kennisnet Ict op school.
+#       http://www.kennisnetictopschool.nl
+#    Copyright (C) 2009 Delft University of Technology http://www.tudelft.nl
+#    Copyright (C) 2009 Tilburg University http://www.uvt.nl
+#    Copyright (C) 2007-2010 Seek You Too (CQ2) http://www.cq2.nl
+#
+#    This file is part of Meresco Oai.
+#
+#    Meresco Oai is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Meresco Oai is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Meresco Oai; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+
+from meresco.core import Observable
+from oaiutils import oaiHeader, oaiFooter, REQUEST, requestUrl, oaiRequestArgs
+
+class OaiError(Observable):
+    def unknown(self, message, **kwargs):
+        result = self.all.unknown(message, **kwargs)
+        try:
+            firstResult = result.next()
+        except StopIteration:
+            yield self._error(**kwargs)
+            return
+        yield firstResult
+        for remainder in result:
+            yield remainder
+
+    def _error(self, arguments, **kwargs):
+        verbs = arguments.get('verb', [None])
+        if verbs[0] is None or verbs[0] == '':
+            yield oaiError('badArgument', 'No "verb" argument found.', arguments=arguments, **kwargs)
+        elif len(verbs) > 1:
+            yield oaiError('badArgument', 'More than one "verb" argument found.', arguments=arguments, **kwargs)
+        else:
+            yield oaiError('badVerb', 'Value of the verb argument is not a legal OAI-PMH verb, the verb argument is missing, or the verb argument is repeated.', arguments=arguments, **kwargs)
+
+
+def oaiError(statusCode, addionalMessage, arguments, **httpkwargs):
+    space = addionalMessage and ' ' or ''
+    message = ERROR_CODES[statusCode] + space + addionalMessage
+
+    yield oaiHeader()
+
+    if statusCode not in ["badArgument", "badResumptionToken", "badVerb"]:
+        """in these cases it is illegal to echo the arguments back; since the arguments are not valid in the first place the responce will not validate either"""
+        yield oaiRequestArgs(arguments, **httpkwargs)
+    else:
+        yield oaiRequestArgs({}, **httpkwargs)
+
+    yield """<error code="%(statusCode)s">%(message)s</error>""" % locals()
+
+    yield oaiFooter()
+
+# http://www.openarchives.org/OAI/openarchivesprotocol.html#ErrorConditions
+ERROR_CODES = {
+    'badArgument': 'The request includes illegal arguments, is missing required arguments, includes a repeated argument, or values for arguments have an illegal syntax.',
+    'badResumptionToken': 'The value of the resumptionToken argument is invalid or expired.',
+    'badVerb': 'Value of the verb argument is not a legal OAI-PMH verb, the verb argument is missing, or the verb argument is repeated.',
+    'cannotDisseminateFormat': 'The metadata format identified by the value given for the metadataPrefix argument is not supported by the item or by the repository.',
+    'idDoesNotExist': 'The value of the identifier argument is unknown or illegal in this repository.',
+    'noRecordsMatch': 'The combination of the values of the from, until, set and metadataPrefix arguments results in an empty list.',
+    'noMetadataFormats': 'There are no metadata formats available for the specified item.',
+    'noSetHierarchy': 'The repository does not support sets.'
+}
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_1/meresco/oai/oaigetrecord.py version_2/meresco/oai/oaigetrecord.py
--- version_1/meresco/oai/oaigetrecord.py	2010-09-28 14:06:30.000000000 +0200
+++ version_2/meresco/oai/oaigetrecord.py	2010-10-04 10:50:13.000000000 +0200
@@ -53,8 +53,9 @@
             'metadataPrefix': 'required'})
         Observable.__init__(self)
 
-    def getRecord(self, webRequest):
-        self.startProcessing(webRequest)
+    def getRecord(self, webrequest, **kwargs):
+        self.startProcessing(webrequest)
+        yield webrequest.generateResponse()
 
     def preProcess(self, webRequest):
         isDeleted = self.any.isDeleted(self._identifier)
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_1/meresco/oai/oaiidentifierrename.py version_2/meresco/oai/oaiidentifierrename.py
--- version_1/meresco/oai/oaiidentifierrename.py	2010-09-28 14:06:30.000000000 +0200
+++ version_2/meresco/oai/oaiidentifierrename.py	2010-10-04 10:50:13.000000000 +0200
@@ -71,7 +71,10 @@
 
     def write(self, sink, id, partName):
         return self.any.write(sink, self._strip(id), partName)
-    
+
+    def yieldRecord(self, identifier, partname):
+        return self.any.yieldRecord(self._strip(identifier), partname)
+
     def getStream(self, id, partName):
         return self.any.getStream(self._strip(id), partName)
     
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_1/meresco/oai/oaiidentify.py version_2/meresco/oai/oaiidentify.py
--- version_1/meresco/oai/oaiidentify.py	2010-09-28 14:06:30.000000000 +0200
+++ version_2/meresco/oai/oaiidentify.py	2010-10-04 10:50:13.000000000 +0200
@@ -72,8 +72,9 @@
         self._adminEmail = adminEmail
         self._repositoryIdentifier = repositoryIdentifier
 
-    def identify(self, webRequest):
-        self.startProcessing(webRequest)
+    def identify(self, webrequest, **kwargs):
+        self.startProcessing(webrequest)
+        yield webrequest.generateResponse()
 
     def process(self, webRequest):
         descriptionRepositoryIdentifier = '' if not self._repositoryIdentifier else DESCRIPTION_REPOSITORY_IDENTIFIER % { 'repositoryIdentifier': escapeXml(self._repositoryIdentifier)}
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_1/meresco/oai/oaijazz.py version_2/meresco/oai/oaijazz.py
--- version_1/meresco/oai/oaijazz.py	2010-09-28 14:06:30.000000000 +0200
+++ version_2/meresco/oai/oaijazz.py	2010-10-04 10:50:13.000000000 +0200
@@ -84,7 +84,7 @@
         self._add(stamp, identifier, oldSets, oldPrefixes)
         self._tombStones.append(stamp)
 
-    def oaiSelect(self, sets=None, prefix='oai_dc', continueAfter='0', oaiFrom=None, oaiUntil=None, batchSize='ignored'):
+    def oaiSelect(self, sets=None, prefix='oai_dc', continueAfter='0', oaiFrom=None, oaiUntil=None):
         sets = [] if sets == None else sets
         start = max(int(continueAfter)+1, self._fromTime(oaiFrom))
         stop = self._untilTime(oaiUntil)
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_1/meresco/oai/oailistmetadataformats.py version_2/meresco/oai/oailistmetadataformats.py
--- version_1/meresco/oai/oailistmetadataformats.py	2010-09-28 14:06:30.000000000 +0200
+++ version_2/meresco/oai/oailistmetadataformats.py	2010-10-04 10:50:13.000000000 +0200
@@ -50,8 +50,9 @@
         OaiVerb.__init__(self, ['ListMetadataFormats'], {'identifier': 'optional'})
         Observable.__init__(self)
 
-    def listMetadataFormats(self, aWebRequest):
-        self.startProcessing(aWebRequest)
+    def listMetadataFormats(self, webrequest, **kwargs):
+        self.startProcessing(webrequest)
+        yield webrequest.generateResponse()
 
     def preProcess(self, webRequest):
         metadataFormats = self.any.getAllMetadataFormats()
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_1/meresco/oai/oailist.py version_2/meresco/oai/oailist.py
--- version_1/meresco/oai/oailist.py	2010-09-28 14:06:30.000000000 +0200
+++ version_2/meresco/oai/oailist.py	2010-10-04 10:50:13.000000000 +0200
@@ -32,11 +32,16 @@
 from resumptiontoken import resumptionTokenFromString, ResumptionToken
 from oaitool import ISO8601, ISO8601Exception
 from oairecordverb import OaiRecordVerb
-from itertools import chain
+from itertools import chain, islice
+from oaiutils import OaiBadArgumentException, doElementaryArgumentsValidation, oaiFooter, oaiHeader, oaiRequestArgs, OaiException
+from oaierror import oaiError
+from xml.sax.saxutils import escape as xmlEscape
+from meresco.core.generatorutils import decorate
+from weightless import compose
 
 BATCH_SIZE = 200
 
-class OaiList(OaiRecordVerb, Observable):
+class OaiList(Observable):
     """4.3 ListIdentifiers
 Summary and Usage Notes
 
@@ -79,75 +84,147 @@
     * noSetHierarchy - The repository does not support sets.
 """
     def __init__(self, batchSize=BATCH_SIZE):
-        OaiRecordVerb.__init__(self, ['ListIdentifiers', 'ListRecords'], {
+        self._supportedVerbs = ['ListIdentifiers', 'ListRecords']
+        self._argsDef = {
             'from': 'optional',
             'until': 'optional',
             'set': 'optional',
             'resumptionToken': 'exclusive',
-            'metadataPrefix': 'required'})
+            'metadataPrefix': 'required'}
         Observable.__init__(self)
         self._batchSize = batchSize
 
-    def listRecords(self, webRequest):
-        self.startProcessing(webRequest)
+    def listRecords(self, arguments, **httpkwargs):
+        yield self.doProcess(arguments, **httpkwargs)
 
-    def listIdentifiers(self, webRequest):
-        self.startProcessing(webRequest)
+    def listIdentifiers(self, arguments, **httpkwargs):
+        yield self.doProcess(arguments, **httpkwargs)
 
-    def preProcess(self, webRequest):
-        if self._resumptionToken:
-            token = resumptionTokenFromString(self._resumptionToken)
+    def doProcess(self, arguments, **httpkwargs):
+        self._verb = arguments.get('verb', [None])[0]
+        if not self._verb in self._supportedVerbs:
+            return
+
+        try:
+            validatedArguments = doElementaryArgumentsValidation(arguments, self._argsDef)
+        except OaiBadArgumentException, e:
+            yield oaiError(e.statusCode, e.additionalMessage, arguments, **httpkwargs)
+            return
+
+        try:
+            results = self.preProcess(validatedArguments, **httpkwargs)
+        except OaiException, e:
+            yield oaiError(e.statusCode, e.additionalMessage, arguments, **httpkwargs)
+            return
+
+        yield oaiHeader()
+        yield oaiRequestArgs(arguments, **httpkwargs)
+
+        yield '<%s>' % self._verb
+        yield self.process(results, validatedArguments, **httpkwargs)
+        yield '</%s>' % self._verb
+
+        yield oaiFooter()
+
+
+    def preProcess(self, validatedArguments, **httpkwargs):
+        if validatedArguments.get('resumptionToken', None):
+            token = resumptionTokenFromString(validatedArguments['resumptionToken'])
             if not token:
-                return self.writeError(webRequest, "badResumptionToken")
+                raise OaiException("badResumptionToken")
             self._continueAfter = token._continueAfter
-            self._metadataPrefix = token._metadataPrefix
-            self._from = token._from
-            self._until = token._until
-            self._set = token._set
+            _from = token._from
+            _until = token._until
+            _set = token._set
+            _metadataPrefix = token._metadataPrefix
         else:
             self._continueAfter = '0'
+            _from = validatedArguments.get('from', None)
+            _until = validatedArguments.get('until', None)
+            _set = validatedArguments.get('set', None)
+            _metadataPrefix = validatedArguments.get('metadataPrefix', None)
+
             try:
-                self._from = self._from and ISO8601(self._from)
-                self._until  = self._until and ISO8601(self._until)
-                if self._from and self._until:
-                    if self._from.isShort() != self._until.isShort():
-                        return self.writeError(webRequest, 'badArgument', 'from and/or until arguments must match in length')
-                    if str(self._from) > str(self._until):
-                        return self.writeError(webRequest, 'badArgument', 'from argument must be smaller than until argument')
-                self._from = self._from and self._from.floor()
-                self._until = self._until and self._until.ceil()
+                _from = _from and ISO8601(_from)
+                _until = _until and ISO8601(_until) 
+                if _from and _until:
+                    if _from.isShort() != _until.isShort():
+                        raise OaiBadArgumentException('from and/or until arguments must match in length')
+                    if str(_from) > str(_until):
+                        raise OaiBadArgumentException('from argument must be smaller than until argument')
+                _from = _from and _from.floor()
+                _until = _until and _until.ceil()
             except ISO8601Exception, e:
-                return self.writeError(webRequest, 'badArgument', 'from and/or until arguments are faulty')
+                raise OaiBadArgumentException('from and/or until arguments are faulty')
 
-        if not self._metadataPrefix in set(self.any.getAllPrefixes()):
-            return self.writeError(webRequest, 'cannotDisseminateFormat')
+        if not _metadataPrefix in set(self.any.getAllPrefixes()):
+            raise OaiException('cannotDisseminateFormat')
+
+        validatedArguments['from'] = _from
+        validatedArguments['until'] = _until
+        validatedArguments['set'] = _set
+        validatedArguments['metadataPrefix'] = _metadataPrefix
 
         result = self.any.oaiSelect(
-            sets=self._set and [self._set] or None,
-            prefix=self._metadataPrefix,
-            continueAfter=self._continueAfter,
-            oaiFrom=self._from,
-            oaiUntil=self._until,
-            batchSize = self._batchSize)
+            sets = [_set] if _set else None,
+            prefix = _metadataPrefix,
+            continueAfter  = self._continueAfter,
+            oaiFrom = _from,
+            oaiUntil = _until)
         try:
             firstRecord = result.next()
-            self._queryRecordIds = chain(iter([firstRecord]), result)
+            return chain(iter([firstRecord]), result)
+        except StopIteration:
+            raise OaiException('noRecordsMatch')
+
+    def process(self, results, validatedArguments, **httpkwargs):
+        for id in islice(results, 0, self._batchSize):
+            yield self.oaiRecord(validatedArguments, id, self._verb == "ListRecords")
+
+        try:
+            results.next()
+            yield '<resumptionToken>%s</resumptionToken>' % ResumptionToken(
+                validatedArguments['metadataPrefix'],
+                self.any.getUnique(id),
+                validatedArguments['from'],
+                validatedArguments['until'],
+                validatedArguments['set'])
+            return
         except StopIteration:
-            self._queryRecordIds = iter([])
-            return self.writeError(webRequest, 'noRecordsMatch')
+            pass
+
+        if validatedArguments['resumptionToken']:
+            yield '<resumptionToken/>'
 
-    def process(self, webRequest):
-        for i, id in enumerate(self._queryRecordIds):
-            if i == self._batchSize:
-                webRequest.write('<resumptionToken>%s</resumptionToken>' % ResumptionToken(
-                    self._metadataPrefix,
-                    self.any.getUnique(prevId),
-                    self._from,
-                    self._until,
-                    self._set))
-                return
-            self.writeRecord(webRequest, id, self._verb == "ListRecords")
-            prevId = id
+    def oaiRecord(self, validatedArguments, recordId, writeBody=True):
+        isDeletedStr = self.any.isDeleted(recordId) and ' status="deleted"' or ''
+        datestamp = self.any.getDatestamp(recordId)
+        setSpecs = self._getSetSpecs(recordId)
+        if writeBody:
+            yield '<record>'
+
+        yield """<header%s>
+            <identifier>%s</identifier>
+            <datestamp>%s</datestamp>
+            %s
+        </header>""" % (isDeletedStr, xmlEscape(recordId.encode('utf-8')), datestamp, setSpecs)
+
+        if writeBody and not isDeletedStr:
+            yield '<metadata>'
+            yield self.all.yieldRecord(recordId, validatedArguments['metadataPrefix'])
+            yield '</metadata>'
+
+        if writeBody:
+            provenance = self.all.provenance(recordId)
+            for line in decorate('<about>', provenance, '</about>'):
+                yield line
+
+        if writeBody:
+            yield '</record>'
+
+    def _getSetSpecs(self, recordId):
+        sets = self.any.getSets(recordId)
+        if sets:
+            return ''.join('<setSpec>%s</setSpec>' % xmlEscape(setSpec) for setSpec in sets)
+        return ''
 
-        if self._resumptionToken:
-            webRequest.write('<resumptionToken/>')
Binary files version_1/meresco/oai/.oailist.py.swp and version_2/meresco/oai/.oailist.py.swp differ
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_1/meresco/oai/oailistsets.py version_2/meresco/oai/oailistsets.py
--- version_1/meresco/oai/oailistsets.py	2010-09-28 14:06:30.000000000 +0200
+++ version_2/meresco/oai/oailistsets.py	2010-10-04 10:50:13.000000000 +0200
@@ -49,8 +49,9 @@
         OaiRecordVerb.__init__(self, ['ListSets'], {'resumptionToken': 'exclusive'})
         Observable.__init__(self)
 
-    def listSets(self, aWebRequest):
-        self.startProcessing(aWebRequest)
+    def listSets(self, webrequest, **kwargs):
+        self.startProcessing(webrequest)
+        yield webrequest.generateResponse()
 
     def preProcess(self, webRequest):
         if self._resumptionToken:
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_1/meresco/oai/oaipmh.py version_2/meresco/oai/oaipmh.py
--- version_1/meresco/oai/oaipmh.py	2010-09-28 14:06:30.000000000 +0200
+++ version_2/meresco/oai/oaipmh.py	2010-10-04 10:50:13.000000000 +0200
@@ -33,35 +33,45 @@
 from oaigetrecord import OaiGetRecord
 from oailistmetadataformats import OaiListMetadataFormats
 from oailistsets import OaiListSets
-from oaisink import OaiSink
+from oaierror import OaiError
 from oaiidentifierrename import OaiIdentifierRename
+from webrequest import WebRequest
 
 class OaiPmh(object):
     def __init__(self, repositoryName, adminEmail, repositoryIdentifier=None):
         outside = Transparant() if repositoryIdentifier == None else OaiIdentifierRename(repositoryIdentifier)
         self.addObserver = outside.addObserver
         self.addStrand = outside.addStrand
+        self._oldFashionedVerbs = [
+                'GetRecord',
+                'ListSets',
+                'ListMetadataFormats',
+                'Identify']
         self._internalObserverTree = be(
             (Observable(),
-                (OaiIdentify(repositoryName=repositoryName, adminEmail=adminEmail, repositoryIdentifier=repositoryIdentifier), ),
-                (OaiList(),
-                    (outside,)
-                ),
-                (OaiGetRecord(),
-                    (outside,)
-                ),
-                (OaiListMetadataFormats(),
-                    (outside,)
-                ),
-                (OaiListSets(),
-                    (outside,)
-                ),
-                (OaiSink(), )
+                (OaiError(),
+                    (OaiIdentify(repositoryName=repositoryName, adminEmail=adminEmail, repositoryIdentifier=repositoryIdentifier), ),
+                    (OaiList(),
+                        (outside,)
+                    ),
+                    (OaiGetRecord(),
+                        (outside,)
+                    ),
+                    (OaiListMetadataFormats(),
+                        (outside,)
+                    ),
+                    (OaiListSets(),
+                        (outside,)
+                    ),
+                )
             )
         )
 
-
-    def handleRequest(self, webrequest):
-        verb = webrequest.args.get('verb',[None])[0]
+    def handleRequest(self, arguments, **kwargs):
+        verb = arguments.get('verb', [None])[0]
         message = verb and verb[0].lower() + verb[1:] or ''
-        return self._internalObserverTree.any.unknown(message, webrequest)
+        webrequest = None
+        if verb in self._oldFashionedVerbs:
+            webrequest = WebRequest(**kwargs)
+        yield self._internalObserverTree.all.unknown(message, arguments=arguments, webrequest=webrequest, **kwargs)
+
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_1/meresco/oai/oairecordverb.py version_2/meresco/oai/oairecordverb.py
--- version_1/meresco/oai/oairecordverb.py	2010-09-28 14:06:30.000000000 +0200
+++ version_2/meresco/oai/oairecordverb.py	2010-10-04 10:50:13.000000000 +0200
@@ -50,7 +50,9 @@
 
         if writeBody and not isDeletedStr:
             webRequest.write('<metadata>')
-            self.any.write(webRequest, recordId, self._metadataPrefix)
+            results = self.any.yieldRecord(recordId, self._metadataPrefix)
+            for line in results:
+                webRequest.write(line)
             webRequest.write('</metadata>')
 
         if writeBody:
Only in version_1/meresco/oai: oaisink.py
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_1/meresco/oai/oaitool.py version_2/meresco/oai/oaitool.py
--- version_1/meresco/oai/oaitool.py	2010-09-28 14:06:30.000000000 +0200
+++ version_2/meresco/oai/oaitool.py	2010-10-04 10:50:13.000000000 +0200
@@ -69,7 +69,10 @@
     
     def __str__(self):
         return self.floor()
-    
+   
+    def __repr__(self):
+        return str(self.s)
+
     def isShort(self):
         return len(self.s) == self.short
 
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_1/meresco/oai/oaiutils.py version_2/meresco/oai/oaiutils.py
--- version_1/meresco/oai/oaiutils.py	1970-01-01 01:00:00.000000000 +0100
+++ version_2/meresco/oai/oaiutils.py	2010-10-04 10:50:13.000000000 +0200
@@ -0,0 +1,103 @@
+
+from time import strftime, gmtime
+from socket import gethostname
+from meresco.components.http.utils import okXml
+from xml.sax.saxutils import escape as xmlEscape
+
+HOSTNAME = gethostname()
+
+class OaiException(Exception):
+    def __init__(self, statusCode, additionalMessage=""):
+        Exception.__init__(self, additionalMessage)
+        self.additionalMessage = additionalMessage
+        self.statusCode = statusCode
+
+class OaiBadArgumentException(OaiException):
+    def __init__(self, additionalMessage):
+        OaiException.__init__(self, 'badArgument', additionalMessage)
+
+def zuluTime():
+    return strftime('%Y-%m-%dT%H:%M:%SZ', gmtime())
+
+def requestUrl(Headers, path, port, **kwargs):
+    hostname = Headers.get('Host', HOSTNAME).split(':')[0]
+    return 'http://%s:%s%s' % (hostname, port, path)
+
+def oaiHeader():
+    yield okXml
+    yield OAIHEADER
+    yield RESPONSE_DATE % zuluTime()
+
+def oaiFooter():
+    yield OAIFOOTER
+
+def oaiRequestArgs(arguments, **httpkwargs):
+    url = requestUrl(**httpkwargs)
+    args = ' '.join(['%s="%s"' % (xmlEscape(k), xmlEscape(v[0]).replace('"', '&quot;')) for k,v in sorted(arguments.items())])
+    yield REQUEST % locals()
+
+
+def doElementaryArgumentsValidation(arguments, argsDef):
+    validatedArguments = {}
+
+    if _isArgumentRepeated(arguments):
+        raise OaiBadArgumentException('Argument "%s" may not be repeated.' % _isArgumentRepeated(arguments))
+
+    exclusiveArguments = _select('exclusive', argsDef)
+    for exclusiveArgument in exclusiveArguments:
+        if exclusiveArgument in arguments.keys():
+            if set(arguments.keys()) != set(['verb', exclusiveArgument]):
+                raise OaiBadArgumentException('"%s" argument may only be used exclusively.' % exclusiveArgument)
+            validatedArguments[exclusiveArgument] = arguments[exclusiveArgument][0]
+            return validatedArguments
+        else:
+            validatedArguments[exclusiveArgument] = None
+
+    missing = []
+    for requiredArgument in _select('required', argsDef):
+        if not requiredArgument in arguments.keys():
+            missing.append(requiredArgument)
+        else:
+            validatedArguments[requiredArgument] = arguments[requiredArgument][0]
+    quote = lambda l: (map(lambda s: '"%s"' % s, l))
+    if missing:
+        raise OaiBadArgumentException('Missing argument(s) ' + \
+            " or ".join(quote(exclusiveArguments) + \
+            [" and ".join(quote(missing))]) + ".")
+
+    for optionalArgument in _select('optional', argsDef):
+        validatedArguments[optionalArgument] = arguments.get(optionalArgument, [None])[0]
+
+    tooMuch = set(arguments.keys()).difference(argsDef.keys() + ['verb'])
+    if tooMuch:
+        raise OaiBadArgumentException('Argument(s) %s is/are illegal.' % ", ".join(map(lambda s: '"%s"' %s, tooMuch)))
+
+    return validatedArguments
+
+def _isArgumentRepeated(arguments):
+    for k, v in arguments.items():
+        if len(v) > 1:
+            return k
+    return False
+
+def _select(neededNess, argsDef):
+    result = []
+    for arg, definition in argsDef.items():
+        if definition == neededNess:
+            result.append(arg)
+    return result
+
+OAIHEADER = """<?xml version="1.0" encoding="UTF-8"?>
+<OAI-PMH xmlns="http://www.openarchives.org/OAI/2.0/"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://www.openarchives.org/OAI/2.0/
+         http://www.openarchives.org/OAI/2.0/OAI-PMH.xsd">
+"""
+
+RESPONSE_DATE = """<responseDate>%s</responseDate>"""
+
+REQUEST = """<request %(args)s>%(url)s</request>"""
+
+OAIFOOTER = """</OAI-PMH>"""
+
+
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_1/meresco/oai/oaiverb.py version_2/meresco/oai/oaiverb.py
--- version_1/meresco/oai/oaiverb.py	2010-09-28 14:06:30.000000000 +0200
+++ version_2/meresco/oai/oaiverb.py	2010-10-04 10:50:13.000000000 +0200
@@ -29,6 +29,9 @@
 
 from time import gmtime, strftime
 from xml.sax.saxutils import escape as xmlEscape
+from oaierror import ERROR_CODES, oaiError
+from oaiutils import RESPONSE_DATE, REQUEST, OAIHEADER, zuluTime, doElementaryArgumentsValidation, OaiBadArgumentException, oaiFooter, oaiHeader, oaiRequestArgs
+from weightless import compose
 
 class OaiVerb(object):
 
@@ -41,9 +44,12 @@
         if not self._verb in self._supportedVerbs:
             return
 
-        error = self._doElementaryArgumentsValidation(webRequest)
-        if error:
-            return self.writeError(webRequest, 'badArgument', error)
+        try:
+            validatedArguments = doElementaryArgumentsValidation(webRequest.args, self._argsDef)
+            for k,v in validatedArguments.items():
+                setattr(self, "_" + k, v)
+        except OaiBadArgumentException, e:
+            return self.writeError(webRequest, e.statusCode, e.additionalMessage)
 
         error = self.preProcess(webRequest)
         if error:
@@ -73,105 +79,19 @@
         return 'http://%s:%s' % (webRequest.getRequestHostname(), webRequest.getHost().port) + webRequest.path
 
     def writeHeader(self, webRequest):
-        webRequest.setHeader('content-type', 'text/xml; charset=utf-8')
-        webRequest.write(OAIHEADER)
-        webRequest.write(RESPONSE_DATE % self.getTime())
+        for line in compose(oaiHeader()):
+            webRequest.write(line)
 
     def writeRequestArgs(self, webRequest):
-        url = self.getRequestUrl(webRequest)
-        args = ' '.join(['%s="%s"' % (xmlEscape(k), xmlEscape(v[0]).replace('"', '&quot;')) for k,v in sorted(webRequest.args.items())])
-        webRequest.write(REQUEST % locals())
-
-    def writeError(self, webRequest, statusCode, addionalMessage = '', echoArgs = True):
-        space = addionalMessage and ' ' or ''
-        message = ERROR_CODES[statusCode] + space + addionalMessage
-        self.writeHeader(webRequest)
-        url = self.getRequestUrl(webRequest)
-        if statusCode in ["badArgument", "badResumptionToken", "badVerb"]:
-            """in these cases it is illegal to echo the arguments back; since the arguments are not valid in the first place the responce will not validate either"""
-            args = ''
-            webRequest.write(REQUEST % locals())
-        else:
-            self.writeRequestArgs(webRequest)
-        webRequest.write(ERROR % locals())
-        self.writeFooter(webRequest)
+        for line in compose(oaiRequestArgs(webRequest.args, **webRequest.kwargs)):
+            webRequest.write(line)
+
+    def writeError(self, webRequest, statusCode, additionalMessage = '', echoArgs = True):
+        for line in compose(oaiError(statusCode, additionalMessage, arguments=webRequest.args, **webRequest.kwargs)):
+            webRequest.write(line)
         return statusCode
 
     def writeFooter(self, webRequest):
-        webRequest.write(OAIFOOTER)
-
-    def _isArgumentRepeated(self, webRequest):
-        for k, v in webRequest.args.items():
-            if len(v) > 1:
-                return k
-        return False
-
-    def _select(self, neededNess):
-        result = []
-        for arg, definition in self._argsDef.items():
-            if definition == neededNess:
-                result.append(arg)
-        return result
-
-    def ___set(self, key, value):
-        setattr(self, "_" + key, value[0])
-
-    def _doElementaryArgumentsValidation(self, webRequest):
-        if self._isArgumentRepeated(webRequest):
-            return 'Argument "%s" may not be repeated.' % self._isArgumentRepeated(webRequest)
-
-        exclusiveArguments = self._select('exclusive')
-        for exclusiveArgument in exclusiveArguments:
-            if exclusiveArgument in webRequest.args.keys():
-                if set(webRequest.args.keys()) != set(['verb', exclusiveArgument]):
-                    return '"%s" argument may only be used exclusively.' % exclusiveArgument
-                self.___set(exclusiveArgument, webRequest.args[exclusiveArgument])
-                return
-            else:
-                self.___set(exclusiveArgument, [None])
-
-        missing = []
-        for requiredArgument in self._select('required'):
-            if not requiredArgument in webRequest.args.keys():
-                missing.append(requiredArgument)
-            self.___set(requiredArgument, webRequest.args.get(requiredArgument, [None]))
-        quote = lambda l: (map(lambda s: '"%s"' % s, l))
-        if missing:
-            return 'Missing argument(s) ' + \
-                " or ".join(quote(exclusiveArguments) + \
-                [" and ".join(quote(missing))]) + "."
-
-        for optionalArgument in self._select('optional'):
-            self.___set(optionalArgument, webRequest.args.get(optionalArgument, [None]))
-
-        tooMuch = set(webRequest.args.keys()).difference(self._argsDef.keys() + ['verb'])
-        if tooMuch:
-            return 'Argument(s) %s is/are illegal.' % ", ".join(map(lambda s: '"%s"' %s, tooMuch))
-
-OAIHEADER = """<?xml version="1.0" encoding="UTF-8"?>
-<OAI-PMH xmlns="http://www.openarchives.org/OAI/2.0/"
-         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://www.openarchives.org/OAI/2.0/
-         http://www.openarchives.org/OAI/2.0/OAI-PMH.xsd">
-"""
-
-RESPONSE_DATE = """<responseDate>%s</responseDate>"""
-
-REQUEST = """<request %(args)s>%(url)s</request>"""
-
-OAIFOOTER = """</OAI-PMH>"""
-
-ERROR = """<error code="%(statusCode)s">%(message)s</error>"""
-
-# http://www.openarchives.org/OAI/openarchivesprotocol.html#ErrorConditions
-ERROR_CODES = {
-    'badArgument': 'The request includes illegal arguments, is missing required arguments, includes a repeated argument, or values for arguments have an illegal syntax.',
-    'badResumptionToken': 'The value of the resumptionToken argument is invalid or expired.',
-    'badVerb': 'Value of the verb argument is not a legal OAI-PMH verb, the verb argument is missing, or the verb argument is repeated.',
-    'cannotDisseminateFormat': 'The metadata format identified by the value given for the metadataPrefix argument is not supported by the item or by the repository.',
-    'idDoesNotExist': 'The value of the identifier argument is unknown or illegal in this repository.',
-    'noRecordsMatch': 'The combination of the values of the from, until, set and metadataPrefix arguments results in an empty list.',
-    'noMetadataFormats': 'There are no metadata formats available for the specified item.',
-    'noSetHierarchy': 'The repository does not support sets.'
-}
+        for line in compose(oaiFooter()):
+            webRequest.write(line)
 
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_1/meresco/oai/webrequest.py version_2/meresco/oai/webrequest.py
--- version_1/meresco/oai/webrequest.py	1970-01-01 01:00:00.000000000 +0100
+++ version_2/meresco/oai/webrequest.py	2010-10-04 10:50:13.000000000 +0200
@@ -0,0 +1,78 @@
+## begin license ##
+#
+#    Meresco Components are components to build searchengines, repositories
+#    and archives, based on Meresco Core.
+#    Copyright (C) 2007-2010 Seek You Too (CQ2) http://www.cq2.nl
+#    Copyright (C) 2007-2009 SURF Foundation. http://www.surf.nl
+#    Copyright (C) 2007-2009 Stichting Kennisnet Ict op school.
+#       http://www.kennisnetictopschool.nl
+#    Copyright (C) 2007 SURFnet. http://www.surfnet.nl
+#
+#    This file is part of Meresco Components.
+#
+#    Meresco Components is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+#    Meresco Components is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#    GNU General Public License for more details.
+#
+#    You should have received a copy of the GNU General Public License
+#    along with Meresco Components; if not, write to the Free Software
+#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+## end license ##
+from meresco.core import Observable
+from weightless import HttpServer
+from cgi import parse_qs
+from urlparse import urlsplit
+from StringIO import StringIO
+from socket import gethostname
+
+class WebRequest(object):
+    def __init__(self, **kwargs):
+        Scheme, Netloc, Path, Query, Fragment = urlsplit(kwargs['RequestURI'])
+        self.kwargs = kwargs
+        self.stream = StringIO()
+        self.write = self.stream.write
+        self.path = Path
+        self.method = kwargs.get('Method', None)
+        self.uri = kwargs['RequestURI']
+        self.args = parse_qs(Query)
+        self.client = self
+        self.host = kwargs['Client'][0]
+        self.headers = kwargs['Headers']
+        host = self
+        host.port = kwargs['port']
+        self.getHost = lambda: host
+        self.headersOut = {}
+        self.responseCode = 200
+        if kwargs.has_key('Body'):
+            self.content = StringIO(kwargs['Body'])
+
+    def getRequestHostname(self):
+        return self.headers.get('Host', gethostname()).split(':')[0]
+
+    def setResponseCode(self, code):
+        self.responseCode = code
+
+    def setHeader(self, key, value):
+        self.headersOut[key] = value
+
+    def __str__(self):
+        return '\t'.join((self.client.host, self.method, self.uri))
+
+    def generateResponse(self):
+        self.stream.seek(0)
+        if not self.stream.getvalue().startswith('HTTP/1.'):
+            yield 'HTTP/1.0 %s Ok\r\n' % self.responseCode
+            for key, value in self.headersOut.items():
+                yield key.title() + ': ' + value + '\r\n'
+            yield '\r\n'
+        self.stream.seek(0)
+        for line in self.stream.readlines():
+            yield line
+
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_1/test/mockoaijazz.py version_2/test/mockoaijazz.py
--- version_1/test/mockoaijazz.py	2010-09-28 14:06:30.000000000 +0200
+++ version_2/test/mockoaijazz.py	2010-10-04 10:50:13.000000000 +0200
@@ -60,28 +60,28 @@
     def getAllPrefixes(self):
         return ['oai_dc']
 
-    def write(self, sink, id, partName):
+    def yieldRecord(self, id, partName):
         if partName == 'oai_dc':
-            sink.write('<some:recorddata xmlns:some="http://some.example.org" id="%s"/>' % id.replace('&', '&amp;'))
+            yield '<some:recorddata xmlns:some="http://some.example.org" id="%s"/>' % id.replace('&', '&amp;')
         elif partName == 'meta':
-            sink.write("""<meta>
+            yield """<meta>
   <repository>
     <baseurl>META_BASEURL</baseurl>
     <harvestdate>META_HARVESTDATE</harvestdate>
     <metadataNamespace>META_METADATANAMESPACE</metadataNamespace>
   </repository>
-</meta>""")
+</meta>"""
         elif partName == 'header':
-            sink.write("""<header xmlns="http://www.openarchives.org/OAI/2.0/">
+            yield """<header xmlns="http://www.openarchives.org/OAI/2.0/">
             <identifier>HEADER_IDENTIFIER</identifier>
             <datestamp>HEADER_DATESTAMP</datestamp>
-        </header>""")
+        </header>"""
         elif partName == '__stamp__':
-            sink.write("""<__stamp__>
+            yield """<__stamp__>
     <datestamp>DATESTAMP_FOR_TEST</datestamp>
-</__stamp__>""")
+</__stamp__>"""
         elif partName == '__sets__':
-            sink.write("""<__sets__><set><setSpec>one:two:three</setSpec><setName>Three Piggies</setName></set><set><setSpec>one:two:four</setSpec><setName>Four Chickies</setName></set></__sets__>""")
+            yield """<__sets__><set><setSpec>one:two:three</setSpec><setName>Three Piggies</setName></set><set><setSpec>one:two:four</setSpec><setName>Four Chickies</setName></set></__sets__>"""
         else:
             self.fail(partName + ' is unexpected')
 
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_1/test/oaigetrecordtest.py version_2/test/oaigetrecordtest.py
--- version_1/test/oaigetrecordtest.py	2010-09-28 14:06:30.000000000 +0200
+++ version_2/test/oaigetrecordtest.py	2010-10-04 10:50:13.000000000 +0200
@@ -33,6 +33,7 @@
 
 from meresco.core import ObserverFunction
 from meresco.oai.oaigetrecord import OaiGetRecord
+from meresco.components.http.utils import CRLF
 
 from cq2utils.calltrace import CallTrace
 
@@ -55,12 +56,11 @@
         observer.returnValues['getDatestamp'] = 'DATESTAMP_FOR_TEST'
         self.subject.addObserver(observer)
 
-        self.observable.any.getRecord(self.request)
-
-        self.assertEqualsWS(self.OAIPMH % """
-<request identifier="oai:ident" metadataPrefix="oai_dc" verb="GetRecord">http://server:9000/path/to/oai</request>
-<error code="idDoesNotExist">The value of the identifier argument is unknown or illegal in this repository.</error>""", self.stream.getvalue())
-        self.assertValidString(self.stream.getvalue())
+        list(self.observable.all.getRecord(self.request))
+        body = self.stream.getvalue().split(CRLF*2)[-1]
+        self.assertTrue("""<request identifier="oai:ident" metadataPrefix="oai_dc" verb="GetRecord">http://server:9000/path/to/oai</request>""" in body, body)
+        self.assertTrue("""<error code="idDoesNotExist">The value of the identifier argument is unknown or illegal in this repository.</error>""" in body, body)
+        self.assertValidString(body)
 
         self.assertEquals([('oai:ident', 'oai_dc')], notifications)
 
@@ -70,22 +70,11 @@
         self.subject.addObserver(MockOaiJazz(
             isAvailableDefault=(True, False),
             isAvailableAnswer=[(None, 'oai_dc', (True,True))]))
-        self.observable.any.getRecord(self.request)
-        self.assertEqualsWS(self.OAIPMH % """
-<request identifier="oai:ident"
- metadataPrefix="oai_dc"
- verb="GetRecord">http://server:9000/path/to/oai</request>
-   <GetRecord>
-   <record>
-    <header>
-      <identifier>oai:ident</identifier>
-      <datestamp>DATESTAMP_FOR_TEST</datestamp>
-    </header>
-    <metadata>
-      <some:recorddata xmlns:some="http://some.example.org" id="oai:ident"/>
-    </metadata>
-  </record>
- </GetRecord>""", self.stream.getvalue())
+        list(self.observable.all.getRecord(self.request))
+        body = self.stream.getvalue().split(CRLF*2)[-1]
+        self.assertTrue("<GetRecord>" in body, body)
+        self.assertTrue("<identifier>oai:ident</identifier>" in body, body)
+        self.assertTrue("""<some:recorddata xmlns:some="http://some.example.org" id="oai:ident"/>""" in body, body)
 
     def testDeletedRecord(self):
         self.request.args = {'verb':['GetRecord'], 'metadataPrefix': ['oai_dc'], 'identifier': ['oai:ident']}
@@ -94,5 +83,5 @@
             isAvailableDefault=(True, False),
             isAvailableAnswer=[(None, "oai_dc", (True, False))],
             deleted=['oai:ident']))
-        self.observable.any.getRecord(self.request)
+        list(self.observable.all.getRecord(self.request))
         self.assertTrue("deleted" in self.stream.getvalue(), self.stream.getvalue())
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_1/test/oaijazzimplementationstest.py version_2/test/oaijazzimplementationstest.py
--- version_1/test/oaijazzimplementationstest.py	2010-09-28 14:06:30.000000000 +0200
+++ version_2/test/oaijazzimplementationstest.py	2010-10-04 10:50:13.000000000 +0200
@@ -32,12 +32,13 @@
 from meresco.components.facetindex import LuceneIndex
 from os.path import join
 from meresco.components import StorageComponent
+from meresco.components.http.utils import CRLF
 from time import sleep, mktime
 from StringIO import StringIO
 from lxml.etree import parse
 from meresco.oai.oailist import OaiList
-
 from meresco.oai import OaiJazz, OaiAddRecord
+from weightless import compose
 
 parseLxml = lambda s: parse(StringIO(s)).getroot()
 
@@ -254,31 +255,28 @@
         BATCH_SIZE = 10
         for i in xrange(BATCH_SIZE + 5):
             self.jazz.addOaiRecord('id:%i' % i, metadataFormats=[('prefix', 'schema', 'namespace')])
-        output = StringIO()
         oaiList = OaiList(batchSize=BATCH_SIZE)
         oaiList.addObserver(self.jazz)
         host = CallTrace('Host')
         host.port = 12345
-        webrequest = CallTrace('WebRequest')
-        webrequest.write = output.write
-        webrequest.args = {'verb': ['ListIdentifiers'], 'metadataPrefix': ['prefix']}
-        webrequest.path = '/oai'
-        webrequest.returnValues['getRequestHostname'] = 'www.example.org'
-        webrequest.returnValues['getHost'] = host
-        oaiList.listIdentifiers(webrequest)
-        output.seek(0)
-        lxmlNode = parse(output)
+        request = CallTrace('Request')
+        request.args = {'verb': ['ListIdentifiers'], 'metadataPrefix': ['prefix']}
+        request.kwargs = {'Headers':{'Host':'www.example.org'}, 'port':12345, 'path':'/oai'}
+        request.path = '/oai'
+        request.returnValues['getRequestHostname'] = 'www.example.org'
+        request.returnValues['getHost'] = host
+        result = ''.join(compose(oaiList.listIdentifiers(request.args, **request.kwargs)))
+        body = result.split(CRLF*2)[-1]
+        lxmlNode = parse(StringIO(body))
         recordIds = lxmlNode.xpath('//oai:identifier/text()', namespaces = {'oai':"http://www.openarchives.org/OAI/2.0/"})
         self.assertEquals(['id:%d' % i for i in range(BATCH_SIZE)], recordIds)
         resumptionToken = ''.join(lxmlNode.xpath('//oai:resumptionToken/text()', namespaces = {'oai':"http://www.openarchives.org/OAI/2.0/"}))
 
         # now use resumptiontoken
-        output = StringIO()
-        webrequest.write = output.write
-        webrequest.args = {'verb': ['ListIdentifiers'], 'resumptionToken':[resumptionToken]}
-        oaiList.listIdentifiers(webrequest)
-        output.seek(0)
-        lxmlNode = parse(output)
+        request.args = {'verb': ['ListIdentifiers'], 'resumptionToken':[resumptionToken]}
+        result = ''.join(compose(oaiList.listIdentifiers(request.args, **request.kwargs)))
+        body = result.split(CRLF*2)[-1]
+        lxmlNode = parse(StringIO(body))
         recordIds = lxmlNode.xpath('//oai:identifier/text()', namespaces = {'oai':"http://www.openarchives.org/OAI/2.0/"})
         self.assertEquals(['id:%d' % i for i in range(BATCH_SIZE, BATCH_SIZE +5)], recordIds)
 
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_1/test/oailistmetadataformatstest.py version_2/test/oailistmetadataformatstest.py
--- version_1/test/oailistmetadataformatstest.py	2010-09-28 14:06:30.000000000 +0200
+++ version_2/test/oailistmetadataformatstest.py	2010-10-04 10:50:13.000000000 +0200
@@ -32,6 +32,7 @@
 from oaitestcase import OaiTestCase
 from meresco.components.facetindex import LuceneIndex
 from meresco.components import StorageComponent
+from meresco.components.http.utils import CRLF
 from meresco.oai import OaiAddRecord, OaiJazz
 from meresco.oai.oailistmetadataformats import OaiListMetadataFormats
 from meresco.core import be, Observable
@@ -56,25 +57,20 @@
                 ]
         self.subject.addObserver(MockJazz())
         self.request.args = {'verb': ['ListMetadataFormats']}
-        self.observable.any.listMetadataFormats(self.request)
-        self.assertEqualsWS(self.OAIPMH % """
-        <request verb="ListMetadataFormats">http://server:9000/path/to/oai</request>
-  <ListMetadataFormats>
-   <metadataFormat>
-     <metadataPrefix>oai_dc</metadataPrefix>
-     <schema>http://www.openarchives.org/OAI/2.0/oai_dc.xsd
-       </schema>
-     <metadataNamespace>http://www.openarchives.org/OAI/2.0/oai_dc/
-       </metadataNamespace>
-   </metadataFormat>
-   <metadataFormat>
-     <metadataPrefix>olac</metadataPrefix>
-     <schema>http://www.language-archives.org/OLAC/olac-0.2.xsd</schema>
-     <metadataNamespace>http://www.language-archives.org/OLAC/0.2/
-      </metadataNamespace>
-   </metadataFormat>
-  </ListMetadataFormats>""", self.stream.getvalue())
-        self.assertValidString(self.stream.getvalue())
+        list(self.observable.all.listMetadataFormats(self.request))
+        body = self.stream.getvalue().split(CRLF*2)[-1]
+        self.assertTrue("""<ListMetadataFormats>""" in body, body)
+        self.assertTrue("""<metadataFormat>
+                <metadataPrefix>oai_dc</metadataPrefix>
+                <schema>http://www.openarchives.org/OAI/2.0/oai_dc.xsd</schema>
+                <metadataNamespace>http://www.openarchives.org/OAI/2.0/oai_dc/</metadataNamespace>
+            </metadataFormat>""" in body, body)
+        self.assertTrue("""<metadataFormat>
+                <metadataPrefix>olac</metadataPrefix>
+                <schema>http://www.language-archives.org/OLAC/olac-0.2.xsd</schema>
+                <metadataNamespace>http://www.language-archives.org/OLAC/0.2/</metadataNamespace>
+            </metadataFormat>""" in body, body)
+        self.assertValidString(body)
 
     def assertWithJazz(self, jazz):
         server = be((Observable(),
@@ -88,21 +84,20 @@
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://www.openarchives.org/OAI/2.0/oai_dc/ http://www.openarchives.org/OAI/2.0/oai_dc.xsd"></oai_dc:dc>"""))
         server.do.add(identifier='id_0', partname='olac', lxmlNode=parseLxml('<tag/>'))
-        self.subject.listMetadataFormats(self.request)
-        self.assertEqualsWS(self.OAIPMH % """<request identifier="id_0" verb="ListMetadataFormats">http://server:9000/path/to/oai</request>
-    <ListMetadataFormats>
-        <metadataFormat>
-            <metadataPrefix>oai_dc</metadataPrefix>
-            <schema>http://www.openarchives.org/OAI/2.0/oai_dc.xsd</schema>
-            <metadataNamespace>http://www.openarchives.org/OAI/2.0/oai_dc/</metadataNamespace>
-        </metadataFormat>
-        <metadataFormat>
-            <metadataPrefix>olac</metadataPrefix>
-            <schema></schema>
-            <metadataNamespace></metadataNamespace>
-        </metadataFormat>
-  </ListMetadataFormats>""", self.stream.getvalue())
-        self.assertValidString(self.stream.getvalue())
+        list(self.subject.listMetadataFormats(self.request))
+        body = self.stream.getvalue().split(CRLF*2)[-1]
+        self.assertTrue("<ListMetadataFormats>" in body, body)
+        self.assertTrue("""<metadataFormat>
+                <metadataPrefix>oai_dc</metadataPrefix>
+                <schema>http://www.openarchives.org/OAI/2.0/oai_dc.xsd</schema>
+                <metadataNamespace>http://www.openarchives.org/OAI/2.0/oai_dc/</metadataNamespace>
+            </metadataFormat>""" in body, body)
+        self.assertTrue("""<metadataFormat>
+                <metadataPrefix>olac</metadataPrefix>
+                <schema></schema>
+                <metadataNamespace></metadataNamespace>
+            </metadataFormat>""" in body, body)
+        self.assertValidString(body)
 
     def testListMetadataFormatsForIdentifierFile(self):
         jazz = OaiJazz(self.tempdir)
@@ -116,6 +111,7 @@
                 return []
         self.request.args = {'verb': ['ListMetadataFormats'], 'identifier': ['DoesNotExist']}
         self.subject.addObserver(Observer())
-        self.observable.any.listMetadataFormats(self.request)
-        self.assertTrue("""<error code="idDoesNotExist">The value of the identifier argument is unknown or illegal in this repository.</error>""" in self.stream.getvalue())
-        self.assertValidString(self.stream.getvalue())
+        list(self.observable.all.listMetadataFormats(self.request))
+        body = self.stream.getvalue().split(CRLF*2)[-1]
+        self.assertTrue("""<error code="idDoesNotExist">The value of the identifier argument is unknown or illegal in this repository.</error>""" in body, body)
+        self.assertValidString(body)
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_1/test/oailistsetstest.py version_2/test/oailistsetstest.py
--- version_1/test/oailistsetstest.py	2010-09-28 14:06:30.000000000 +0200
+++ version_2/test/oailistsetstest.py	2010-10-04 10:50:13.000000000 +0200
@@ -34,23 +34,20 @@
 from meresco.oai.oailistsets import OaiListSets
 from meresco.components.facetindex import LuceneIndex
 from meresco.components import StorageComponent
+from meresco.components.http.utils import CRLF
 
 class OaiListSetsTest(OaiTestCase):
     def getSubject(self):
         return OaiListSets()
 
-
-
     def testListSetsNoArguments(self):
         mockJazz = CallTrace(returnValues = {'getAllSets': ['some:name:id_0', 'some:name:id_1']})
         self.request.args = {'verb':['ListSets']}
         self.subject.addObserver(mockJazz)
-        self.subject.listSets(self.request)
-        self.assertEqualsWS(self.OAIPMH % """
-<request verb="ListSets">http://server:9000/path/to/oai</request>
- <ListSets>
-   <set><setSpec>some:name:id_0</setSpec><setName>set some:name:id_0</setName></set>
-   <set><setSpec>some:name:id_1</setSpec><setName>set some:name:id_1</setName></set>
- </ListSets>""", self.stream.getvalue())
-        self.assertFalse('<resumptionToken' in self.stream.getvalue())
+        list(self.subject.listSets(self.request))
+        body = self.stream.getvalue().split(CRLF*2)[-1]
+        self.assertTrue("""<ListSets>""" in body, body)
+        self.assertTrue("""<set><setSpec>some:name:id_0</setSpec><setName>set some:name:id_0</setName></set>""" in body, body)
+        self.assertTrue("""<set><setSpec>some:name:id_1</setSpec><setName>set some:name:id_1</setName></set>""" in body, body)
+        self.assertFalse('<resumptionToken' in body, body)
 
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_1/test/oailisttest.py version_2/test/oailisttest.py
--- version_1/test/oailisttest.py	2010-09-28 14:06:30.000000000 +0200
+++ version_2/test/oailisttest.py	2010-10-04 10:50:13.000000000 +0200
@@ -26,7 +26,7 @@
 #    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 #
 ## end license ##
-
+from lxml.etree import parse, tostring
 from StringIO import StringIO
 
 from amara.binderytools import bind_string
@@ -35,11 +35,15 @@
 
 from mockoaijazz import MockOaiJazz
 
+from meresco.components.http.utils import CRLF
 from meresco.core import ObserverFunction
 from meresco.oai.oailist import BATCH_SIZE, OaiList
 from meresco.oai.resumptiontoken import resumptionTokenFromString, ResumptionToken
 
 from oaitestcase import OaiTestCase
+from meresco.oai.oaiutils import OaiException
+
+from weightless import compose
 
 class OaiListTest(OaiTestCase):
     def getSubject(self):
@@ -59,32 +63,13 @@
                 (None, '__tombstone__', (True, False))])
         self.subject.addObserver(mockoaijazz)
         
-        self.observable.any.listRecords(self.request)
-
-        self.assertEqualsWS(self.OAIPMH % """
-<request metadataPrefix="oai_dc"
- verb="ListRecords">http://server:9000/path/to/oai</request>
- <ListRecords>
-   <record>
-    <header>
-      <identifier>id_0&amp;0</identifier>
-      <datestamp>DATESTAMP_FOR_TEST</datestamp>
-    </header>
-    <metadata>
-      <some:recorddata xmlns:some="http://some.example.org" id="id_0&amp;0"/>
-    </metadata>
-   </record>
-   <record>
-    <header>
-      <identifier>id_1&amp;1</identifier>
-      <datestamp>DATESTAMP_FOR_TEST</datestamp>
-    </header>
-    <metadata>
-      <some:recorddata xmlns:some="http://some.example.org" id="id_1&amp;1"/>
-    </metadata>
-   </record>
- </ListRecords>""" , self.stream.getvalue())
-        self.assertTrue(self.stream.getvalue().find('<resumptionToken') == -1)
+        result = ''.join(compose(self.observable.all.listRecords(self.request.args, **self.request.kwargs)))
+        body = result.split(CRLF*2)[-1]
+        self.assertTrue("""<identifier>id_0&amp;0</identifier>""" in body, body)
+        self.assertTrue("""<identifier>id_1&amp;1</identifier>""" in body, body)
+        self.assertTrue("""<some:recorddata xmlns:some="http://some.example.org" id="id_0&amp;0"/>""" in body, body)
+        self.assertTrue("""<some:recorddata xmlns:some="http://some.example.org" id="id_1&amp;1"/>""" in body, body)
+        self.assertTrue(body.find('<resumptionToken') == -1)
         self.assertFalse(mockoaijazz.oaiSelectArguments[0])
 
     def testListRecordsWithoutProvenance(self):
@@ -97,8 +82,9 @@
                 (None, 'oai_dc', (True,False)),
                 (None, '__tombstone__', (True, False))]))
 
-        self.observable.any.listRecords(self.request)
-        self.assertFalse('<about' in self.stream.getvalue())
+        result = ''.join(compose(self.observable.all.listRecords(self.request.args, **self.request.kwargs)))
+        body = result.split(CRLF*2)[-1]
+        self.assertFalse('<about' in body)
 
     def testListRecordsWithProvenance(self):
         class MockOaiProvenance(object):
@@ -115,43 +101,47 @@
                 (None, 'oai_dc', (True,False)),
                 (None, '__tombstone__', (True, False))]))
 
-        self.observable.any.listRecords(self.request)
-        result = self.stream.getvalue()
-        self.assertTrue('<about>PROVENANCE</about>' in result, result)
+        result = ''.join(compose(self.observable.all.listRecords(self.request.args, **self.request.kwargs)))
+        body = result.split(CRLF*2)[-1]
+        self.assertTrue('<about>PROVENANCE</about>' in body, body)
 
     def testListRecordsUsingToken(self):
         self.request.args = {'verb':['ListRecords'], 'resumptionToken': [str(ResumptionToken('oai_dc', '10', 'FROM', 'UNTIL', 'SET'))]}
 
         observer = CallTrace('RecordAnswering')
-        def oaiSelect(sets, prefix, continueAfter, oaiFrom, oaiUntil, batchSize):
+        def oaiSelect(sets, prefix, continueAfter, oaiFrom, oaiUntil):
             self.assertEquals('SET', sets[0])
             self.assertEquals('oai_dc', prefix)
             self.assertEquals('10', continueAfter)
             self.assertEquals('FROM', oaiFrom)
             self.assertEquals('UNTIL', oaiUntil)
-            self.assertEquals(BATCH_SIZE, batchSize)
             return (f for f in [])
 
         observer.oaiSelect = oaiSelect
         self.subject.addObserver(observer)
-        result = self.observable.any.listRecords(self.request)
+        result = ''.join(compose(self.observable.all.listRecords(self.request.args, **self.request.kwargs)))
 
     def testResumptionTokensAreProduced(self):
         self.request.args = {'verb':['ListRecords'], 'metadataPrefix': ['oai_dc'], 'from': ['2000-01-01T00:00:00Z'], 'until': ['2000-12-31T00:00:00Z'], 'set': ['SET']}
         observer = CallTrace('RecordAnswering')
-        def oaiSelect(sets, prefix, continueAfter, oaiFrom, oaiUntil, batchSize):
-            return imap(lambda i: 'id_%i' % i, range(batchSize+1))
+        def oaiSelect(sets, prefix, continueAfter, oaiFrom, oaiUntil):
+            return imap(lambda i: 'id_%i' % i, xrange(999999))
         def writeRecord(*args, **kwargs):
             pass
+        def provenance(*args, **kwargs):
+            yield ""
+        def yieldRecord(*args, **kwargs):
+            yield ""
         observer.oaiSelect = oaiSelect
+        observer.provenance = provenance
+        observer.yieldRecord = yieldRecord
         observer.getUnique = lambda x: 'UNIQUE_FOR_TEST'
         self.subject.addObserver(observer)
         self.subject.writeRecord = writeRecord
-
-        self.observable.any.listRecords(self.request)
-
-        self.assertTrue(self.stream.getvalue().find("<resumptionToken>") > -1)
-        xml = bind_string(self.stream.getvalue()).OAI_PMH.ListRecords.resumptionToken
+        result = ''.join(compose(self.observable.all.listRecords(self.request.args, **self.request.kwargs)))
+        body = result.split(CRLF*2)[-1]
+        self.assertTrue(body.find("<resumptionToken>") > -1)
+        xml = bind_string(body).OAI_PMH.ListRecords.resumptionToken
         resumptionToken = resumptionTokenFromString(str(xml))
         self.assertEquals('UNIQUE_FOR_TEST', resumptionToken._continueAfter)
         self.assertEquals('oai_dc', resumptionToken._metadataPrefix)
@@ -165,10 +155,11 @@
         self.subject.addObserver(MockOaiJazz(selectAnswer=map(lambda i: 'id_%i' % i, range(BATCH_SIZE)), selectTotal = BATCH_SIZE))
         self.subject.writeRecord = lambda *args, **kwargs: None
 
-        self.observable.any.listRecords(self.request)
+        result = ''.join(compose(self.observable.all.listRecords(self.request.args, **self.request.kwargs)))
+        body = result.split(CRLF*2)[-1]
 
-        self.assertTrue(self.stream.getvalue().find("<resumptionToken") > -1)
-        self.assertEquals('', str(bind_string(self.stream.getvalue()).OAI_PMH.ListRecords.resumptionToken))
+        self.assertTrue(body.find("<resumptionToken") > -1)
+        self.assertEquals('', str(bind_string(body).OAI_PMH.ListRecords.resumptionToken))
 
     def testDeletedTombstones(self):
         self.request.args = {'verb':['ListRecords'], 'metadataPrefix': ['oai_dc']}
@@ -179,28 +170,12 @@
             isAvailableDefault=(True,False),
             selectTotal = 2))
 
-        self.observable.any.listRecords(self.request)
-
-        self.assertEqualsWS(self.OAIPMH % """
-<request metadataPrefix="oai_dc"
- verb="ListRecords">http://server:9000/path/to/oai</request>
- <ListRecords>
-   <record>
-    <header>
-      <identifier>id_0</identifier>
-      <datestamp>DATESTAMP_FOR_TEST</datestamp>
-    </header>
-    <metadata>
-      <some:recorddata xmlns:some="http://some.example.org" id="id_0"/>
-    </metadata>
-   </record>
-   <record>
-    <header status="deleted">
-      <identifier>id_1</identifier>
-      <datestamp>DATESTAMP_FOR_TEST</datestamp>
-    </header>
-   </record>
- </ListRecords>""", self.stream.getvalue())
+        result = ''.join(compose(self.observable.all.listRecords(self.request.args, **self.request.kwargs)))
+        body = result.split(CRLF*2)[-1]
+        self.assertTrue("""<header>
+            <identifier>id_0</identifier>""" in body, body)
+        self.assertTrue("""<header status="deleted">
+            <identifier>id_1</identifier>""" in body, body)
 
         self.assertTrue(self.stream.getvalue().find('<resumptionToken') == -1)
 
@@ -215,14 +190,13 @@
         self.subject.addObserver(observer)
 
         def doIt(oaiFrom, oaiUntil):
-            self.stream = StringIO()
-            self.request.write = self.stream.write
             self.request.args = {'verb':['ListRecords'], 'metadataPrefix': ['oai_dc']}
             if oaiFrom:
                 self.request.args['from'] = [oaiFrom]
             if oaiUntil:
                 self.request.args['until'] = [oaiUntil]
-            self.observable.any.listRecords(self.request)
+            result = ''.join(compose(self.observable.all.listRecords(self.request.args, **self.request.kwargs)))
+            self.body = result.split(CRLF*2)[-1]
             return [observer.oaiSelectArguments[3], observer.oaiSelectArguments[4]]
 
         def right(oaiFrom, oaiUntil, expectedFrom = None, expectedUntil = None):
@@ -231,11 +205,11 @@
             resultingOaiFrom, resultingOaiUntil = doIt(oaiFrom, oaiUntil)
             self.assertEquals(expectedFrom, resultingOaiFrom)
             self.assertEquals(expectedUntil, resultingOaiUntil)
-            self.assertTrue(not "<error" in self.stream.getvalue(), self.stream.getvalue())
+            self.assertTrue(not "<error" in self.body, self.body)
 
         def wrong(oaiFrom, oaiUntil):
             doIt(oaiFrom, oaiUntil)
-            self.assertTrue("""<error code="badArgument">""" in self.stream.getvalue())
+            self.assertTrue("""<error code="badArgument">""" in self.body)
 
         #start reading here
         right(None, None)
@@ -255,17 +229,17 @@
             isAvailableDefault=(True,False),
             isAvailableAnswer=[(None, 'oai_dc', (True,True))],
             selectTotal=1))
-        self.observable.any.listIdentifiers(self.request)
+        result = ''.join(compose(self.observable.all.listIdentifiers(self.request.args, **self.request.kwargs)))
+        body = result.split(CRLF*2)[-1]
 
-        self.assertEqualsWS(self.OAIPMH % """
-<request metadataPrefix="oai_dc"
+        self.assertTrue("""<request metadataPrefix="oai_dc"
  verb="ListIdentifiers">http://server:9000/path/to/oai</request>
  <ListIdentifiers>
     <header>
       <identifier>id_0</identifier>
       <datestamp>DATESTAMP_FOR_TEST</datestamp>
     </header>
- </ListIdentifiers>""", self.stream.getvalue())
+ </ListIdentifiers>""", body)
 
     def testListIdentifiersWithProvenance(self):
         class MockOaiProvenance(object):
@@ -279,19 +253,17 @@
             isAvailableAnswer=[(None, 'oai_dc', (True,True))],
             selectTotal=1))
         self.subject.addObserver(MockOaiProvenance())
-        self.observable.any.listIdentifiers(self.request)
-        output = self.stream.getvalue()
-        self.assertFalse('<about>PROVENANCE</about>' in output, output)
+        result = ''.join(compose(self.observable.all.listIdentifiers(self.request.args, **self.request.kwargs)))
+        body = result.split(CRLF*2)[-1]
+        self.assertFalse('<about>PROVENANCE</about>' in body, body)
 
     def testNoRecordsMatch(self):
         self.request.args = {'verb':['ListIdentifiers'], 'metadataPrefix': ['oai_dc']}
 
         self.subject.addObserver(MockOaiJazz(selectTotal = 0))
-        self.observable.any.listIdentifiers(self.request)
-
-        self.assertTrue(self.stream.getvalue().find("noRecordsMatch") > -1)
-
-        self.assertEquals('noRecordsMatch', self.subject.preProcess(self.request))
+        result = ''.join(compose(self.observable.all.listIdentifiers(self.request.args, **self.request.kwargs)))
+        body = result.split(CRLF*2)[-1]
+        self.assertTrue(body.find("noRecordsMatch") > -1)
 
     def testSetsInHeader(self):
         self.request.args = {'verb':['ListRecords'], 'metadataPrefix': ['oai_dc']}
@@ -303,8 +275,8 @@
             isAvailableAnswer=[
                 (None, 'oai_dc', (True, True)),
                 (None, '__sets__', (True, True))]))
-        self.observable.any.listRecords(self.request)
-
-        self.assertTrue("<setSpec>one:two:three</setSpec>" in self.stream.getvalue())
-        self.assertTrue("<setSpec>one:two:four</setSpec>" in self.stream.getvalue())
+        result = ''.join(compose(self.observable.all.listRecords(self.request.args, **self.request.kwargs)))
+        
+        self.assertTrue("<setSpec>one:two:three</setSpec>" in result)
+        self.assertTrue("<setSpec>one:two:four</setSpec>" in result)
 
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_1/test/oaipmhjazztest.py version_2/test/oaipmhjazztest.py
--- version_1/test/oaipmhjazztest.py	2010-09-28 14:06:30.000000000 +0200
+++ version_2/test/oaipmhjazztest.py	2010-10-04 10:50:13.000000000 +0200
@@ -26,21 +26,19 @@
 
 from meresco.oai import OaiPmh, OaiJazz
 from meresco.core import Observable, be
-from meresco.components.http.webrequestserver import WebRequestServer
 from meresco.components.http.utils import CRLF
 from urllib import urlencode
 from lxml.etree import parse
 from StringIO import StringIO
+from weightless import compose
 
 class OaiPmhJazzTest(CQ2TestCase):
     def setUp(self):
         super(OaiPmhJazzTest, self).setUp()
         self.jazz = OaiJazz(self.tempdir)
         self.root = be((Observable(),
-            (WebRequestServer(),
-                (OaiPmh(repositoryName='Repository', adminEmail='admin@cq2.nl'),
-                    (self.jazz,)
-                )
+            (OaiPmh(repositoryName='Repository', adminEmail='admin@cq2.nl'),
+                (self.jazz,)
             )
         ))
         for i in xrange(20):
@@ -57,14 +55,19 @@
                 sets.append(('hierarchical', 'hierarchical toplevel only'))
             self.jazz.addOaiRecord(recordId, sets=sets, metadataFormats=metadataFormats)
 
-    def handleRequest(self, **kwargs):
-        return self.root.all.handleRequest(
-                RequestURI='http://example.org/oai?' + urlencode(kwargs),
-                Headers={},
-                Client=('127.0.0.1', 1324)
-               )
-
     def testBugListRecordsReturnsDoubleValueOnNoRecordsMatch(self):
-        head, body = ''.join(self.handleRequest(verb='ListRecords', metadataPrefix='oai_dc', **{'from':'9999-01-01'})).split(CRLF * 2)
+        arguments = {'verb':['ListRecords'],
+                'metadataPrefix': ['oai_dc'],
+                'from':['9999-01-01']
+            }
+        head, body = ''.join(compose(self.root.all.handleRequest(
+                RequestURI='http://example.org/oai?' + urlencode(arguments, doseq=True),
+                Headers={},
+                Client=('127.0.0.1', 1324),
+                Method="GET",
+                port=9000,
+                arguments=arguments,
+                path='/oai',
+            ))).split(CRLF * 2)
         self.assertTrue(parse(StringIO(body)))
 
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_1/test/oaipmhtest.py version_2/test/oaipmhtest.py
--- version_1/test/oaipmhtest.py	2010-09-28 14:06:30.000000000 +0200
+++ version_2/test/oaipmhtest.py	2010-10-04 10:50:13.000000000 +0200
@@ -36,6 +36,7 @@
 
 from lxml.etree import parse
 from StringIO import StringIO
+from meresco.components.http.utils import CRLF
 
 def xpath(node, path):
     return '\n'.join(node.xpath(path, namespaces={'oai':"http://www.openarchives.org/OAI/2.0/",
@@ -44,14 +45,9 @@
 class _OaiPmhTest(OaiTestCase):
 
     def testIdentify(self):
-        self.request.args = {'verb': ['Identify']}
-        
-        self.observable.do.handleRequest(self.request)
-        
-        result = self.stream.getvalue()
+        header, result = self.handleRequest({'verb':['Identify']})
         self.assertValidString(result)
-        self.stream.seek(0)
-        response = parse(self.stream)
+        response = parse(StringIO(result))
         self.assertEquals('The Repository Name', xpath(response, '/oai:OAI-PMH/oai:Identify/oai:repositoryName/text()'))
         self.assertEquals('http://server:9000/path/to/oai', xpath(response, '/oai:OAI-PMH/oai:request/text()'))
         self.assertEquals('admin@email.extension', xpath(response, '/oai:OAI-PMH/oai:Identify/oai:adminEmail/text()'))
@@ -64,19 +60,17 @@
 
 
     def testGetRecordUsesObservers(self):
-        self.request.args = {'verb':['GetRecord'], 'metadataPrefix': ['oai_dc'], 'identifier': [self.prefix + 'ident']}
         self.observer.returnValues['getAllPrefixes'] = ['oai_dc']
         self.observer.returnValues['isAvailable'] = (True, True)
         self.observer.returnValues['getDatestamp'] = '2008-11-14T15:43:00Z'
         self.observer.ignoredAttributes.append('provenance')
-        def write(sink, identifier, partName):
+        def yieldRecord(identifier, partName):
             self.assertEquals('ident', identifier)
-            sink.write('<oai_dc:dc xmlns:oai_dc="http://www.openarchives.org/OAI/2.0/oai_dc/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dc="http://purl.org/dc/elements/1.1/" xsi:schemaLocation="http://www.openarchives.org/OAI/2.0/oai_dc/ http://www.openarchives.org/OAI/2.0/oai_dc.xsd"/>')
-        self.observer.write = write
+            yield '<oai_dc:dc xmlns:oai_dc="http://www.openarchives.org/OAI/2.0/oai_dc/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dc="http://purl.org/dc/elements/1.1/" xsi:schemaLocation="http://www.openarchives.org/OAI/2.0/oai_dc/ http://www.openarchives.org/OAI/2.0/oai_dc.xsd"/>'
+        self.observer.yieldRecord = yieldRecord
 
-        self.observable.do.handleRequest(self.request)
+        header, result = self.handleRequest({'verb':['GetRecord'], 'metadataPrefix': ['oai_dc'], 'identifier': [self.prefix + 'ident']})
         
-        result = self.stream.getvalue()
         self.assertValidString(result)
         self.assertEquals(['isDeleted', 'getAllPrefixes', 'isAvailable', 'isDeleted', 'getDatestamp', 'getSets', 'unknown'], [m.name for m in self.observer.calledMethods])
         self.assertEquals('ident', self.observer.calledMethods[0].args[0]) #isDeleted
@@ -85,12 +79,10 @@
         self.assertEquals('ident', self.observer.calledMethods[5].args[0]) #getSets
 
     def assertBadArgument(self, arguments, additionalMessage = '', errorCode = "badArgument"):
-        self.request.args = arguments
-
-        self.observable.do.handleRequest(self.request)
+        header, result = self.handleRequest(arguments)
 
-        self.assertEquals("setHeader('content-type', 'text/xml; charset=utf-8')",  str(self.request.calledMethods[0]))
-        result = self.stream.getvalue()
+        headers = header.split(CRLF)
+        self.assertEquals("Content-Type: text/xml; charset=utf-8", headers[-1]) 
         self.assertTrue('<error code="%s">' % errorCode in result)
         self.assertTrue(additionalMessage in result, 'Expected "%s" in "%s"' %(additionalMessage, result))
 
@@ -164,7 +156,6 @@
         self.assertTrue(observable, 'The above code failed.')
 
     def testListRecords(self):
-        self.request.args = {'verb':['ListRecords'], 'metadataPrefix': ['oai_dc']}
 
         self.observer.returnValues['getAllPrefixes'] = ['oai_dc']
         self.observer.returnValues['oaiSelect'] = iter(['ident0', 'ident1'])
@@ -173,14 +164,13 @@
         self.observer.returnValues['getSets'] = iter(['set0'])
         
         self.observer.ignoredAttributes.append('provenance')
-        def write(sink, identifier, partName):
+        def yieldRecord(identifier, partname):
             self.assertEquals('ident', identifier[:5])
-            sink.write('<oai_dc:dc xmlns:oai_dc="http://www.openarchives.org/OAI/2.0/oai_dc/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dc="http://purl.org/dc/elements/1.1/" xsi:schemaLocation="http://www.openarchives.org/OAI/2.0/oai_dc/ http://www.openarchives.org/OAI/2.0/oai_dc.xsd"/>')
-        self.observer.write = write
+            yield '<oai_dc:dc xmlns:oai_dc="http://www.openarchives.org/OAI/2.0/oai_dc/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dc="http://purl.org/dc/elements/1.1/" xsi:schemaLocation="http://www.openarchives.org/OAI/2.0/oai_dc/ http://www.openarchives.org/OAI/2.0/oai_dc.xsd"/>'
+        self.observer.yieldRecord = yieldRecord
 
-        self.observable.do.handleRequest(self.request)
+        header, result = self.handleRequest({'verb':['ListRecords'], 'metadataPrefix': ['oai_dc']})
         
-        result = self.stream.getvalue()
         self.assertValidString(result)
         self.assertEquals(['getAllPrefixes', 'oaiSelect', 'isDeleted', 'getDatestamp', 'getSets', 'unknown', 'isDeleted', 'getDatestamp', 'getSets', 'unknown'], [m.name for m in self.observer.calledMethods])
         self.assertEquals('ident0', self.observer.calledMethods[2].args[0]) #isDeleted
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_1/test/oaitestcase.py version_2/test/oaitestcase.py
--- version_1/test/oaitestcase.py	2010-09-28 14:06:30.000000000 +0200
+++ version_2/test/oaitestcase.py	2010-10-04 10:50:13.000000000 +0200
@@ -35,8 +35,11 @@
 from StringIO import StringIO
 from os.path import join, dirname, abspath
 from glob import glob
+from urllib import urlencode
 
 from meresco.components.xml_generic import  __file__ as xml_genericpath
+from meresco.components.http.utils import CRLF
+from weightless import compose
 
 
 class OaiTestCase(CQ2TestCase):
@@ -56,6 +59,7 @@
         self.request.getHost = lambda: Host()
         self.stream = StringIO()
         self.request.write = self.stream.write
+        self.request.kwargs ={'Headers':{'Host':'server'}, 'port':9000, 'path':'/path/to/oai'}
 
     OAIPMH = """<?xml version="1.0" encoding="UTF-8"?>
 <OAI-PMH xmlns="http://www.openarchives.org/OAI/2.0/"
@@ -66,6 +70,17 @@
 %s
 </OAI-PMH>"""
 
+    def handleRequest(self, args):
+        result = ''.join(compose(self.observable.all.handleRequest(
+            port=9000,
+            path='/path/to/oai',
+            Client=('localhost',12345),
+            RequestURI="http://server:9000/path/to/oai?%s" % urlencode(args, doseq=True),
+            Method="GET",
+            Headers={'Host':'server:9000'},
+            arguments=args)))
+        return result.split(CRLF * 2)
+
     def assertValidString(self, aXmlString):
         schema = getSchema()
         tree = parse(StringIO(aXmlString))
@@ -74,6 +89,7 @@
             for nr, line in enumerate(aXmlString.split('\n')):
                 print nr+1, line
             self.fail(schema.error_log.last_error)
+        self.assertEquals(['http://server:9000/path/to/oai'], tree.xpath('//oai:request/text()', namespaces={'oai':"http://www.openarchives.org/OAI/2.0/"}))
 
 schemaLocation = join(abspath(dirname(__file__)), 'schemas')
 
diff --unidirectional-new-file --exclude='*.so' --exclude='*.o' --exclude=.svn --exclude='*.pyc' --exclude=deps.d --exclude=applied --recursive --unified version_1/test/oaitooltest.py version_2/test/oaitooltest.py
--- version_1/test/oaitooltest.py	2010-09-28 14:06:30.000000000 +0200
+++ version_2/test/oaitooltest.py	2010-10-04 10:50:13.000000000 +0200
@@ -41,6 +41,7 @@
         request.returnValues['getHost'] = getHost
         request.returnValues['getRequestHostname'] = 'localhost'
         request.path = '/oai'
+        request.kwargs = {'Headers':{'Host':'localhost'}, 'port':8000, 'path':'/oai'}
     
         verb = OaiVerb(None, None)
         request.args = {'identifier': ['with a "']}
